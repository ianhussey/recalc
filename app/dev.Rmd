---
title: "Independent t test and Cohen's d from M/SD/N"
author: "Ian Hussey"
date: "`r format(Sys.time(), '%d %B %Y')`"
output:
  html_document:
    code_folding: show
    highlight: haddock
    theme: flatly
    toc: yes
    toc_float: yes
---

# Dependencies

```{r}

library(knitr)
library(kableExtra)
# devtools::install_github("ianhussey/recalc")
library(recalc)

```

# Recalculate independent t-test from summary stats

```{r}

res <- independent_t_test_summary(
  # essential arguments: M/SD/N
  m1 = 10.30,
  m2 = 8.71,
  sd1 = 3.12,
  sd2 = 2.80,
  n1 = 50,
  n2 = 48,
  m_digits = 2, 
  sd_digits = 2,
  
  # optionally supply the reported p value for comparison
  p_operator = "less_than_or_equal_to",
  p = 0.05,
  p_digits = 3,
  # optionally specify p value calculation method
  p_methods = NULL, # if NULL, check all. or one of "student_t", "welch_t" 
  alpha = 0.05,
  
  # optionally supply the reported SMD estimate and its 95% CIs for comparison
  d = 0.53,
  d_ci_lower = 0.20, # currently not used extensively
  d_ci_upper = 0.90, # currently not used extensively
  # optionally specify direction of effect, M1-M2 or M2-M1
  direction = "m1_minus_m2", # one of c("m1_minus_m2", "m2_minus_m1", "both"),
  # optionally specify output rounding method
  input_rounding = NULL, # if NULL, check all. or one of "rounded", "truncated"
  output_rounding = NULL, # if NULL, check all. or one of "half_up", "half_down", "bankers", "trunc"
  d_digits = 2, # number of digits to round SMD output to
  hedges_correction = NULL, # if NULL, check both applying and not applying hedges correction
  # optionally specify CI calculation method. 
  ci_methods = NULL, # if NULL, check all or one of "wald_t", "welch_t", "nct".
  
  # optionally assess the reported SMD can be reproduced by assuming the reported SDs are actually SEs 
  include_se_sd_confusion = FALSE
)

```

## Bounds

```{r}
res$reproduced |>
  kable() |>
  kable_classic(full_width = FALSE)
```

## Individual possible values for p

```{r}
plot_multiverse_p(res)
plot_multiverse_p(res, distinct_and_rounded = FALSE)

# res$p_results |>
#   kable() |>
#   kable_classic(full_width = FALSE)
```

## Individual possible values for SMD

```{r}
plot_multiverse_d(res)
plot_multiverse_d(res, distinct_and_rounded = FALSE)

# res$d_results |>
#   kable() |>
#   kable_classic(full_width = FALSE)
```

# Shiny app dev

```{r}

# inputs and code
library(knitr)
library(kableExtra)
# devtools::install_github("ianhussey/recalc")
library(recalc)

res <- recalc::independent_t_test_summary(
  # mandatory arguments
  m1 = 10.30, # numeric, increments of .01
  m2 = 8.71, # numeric, increments of .01
  sd1 = 3.12, # numeric, increments of .01
  sd2 = 2.80, # numeric, increments of .01
  n1 = 50, # integer, increments of 1
  n2 = 48, # integer, increments of 1
  m_digits = 2, # integer, increments of 1, default 2
  sd_digits = 2, # integer, increments of 1, default 2
  
  # optionally supply the reported p value for comparison
  p_operator = "less_than", # drop down menu, either "less_than", "more_than", or "equals".
  p = 0.05, # numeric, increments of .01 
  p_digits = 3, # integer, increments of 1, default 3
  # optionally specify p value calculation method
  p_methods = NULL, # drop down menu, one of "student_t", "welch_t", defaults to "student_t"
  alpha = 0.05, # numeric, increments of .01, defaults to .05
  
  # optionally supply the reported SMD estimate and its 95% CIs for comparison
  d = 0.53, # numeric, increments of .01
  d_ci_lower = 0.20, # numeric, increments of .01
  d_ci_upper = 0.90, # numeric, increments of .01
  # optionally specify direction of effect, M1-M2 or M2-M1
  direction = "m1_minus_m2", # drop down menu, one of c("m1_minus_m2", "m2_minus_m1", "both"),
  # optionally specify output rounding method
  input_rounding = NULL, # drop down menu, one of NULL, "rounded", "truncated"
  output_rounding = NULL, # drop down menu, one of NULL, "half_up", "half_down", "bankers", "trunc"
  d_digits = 2, # integer, increments of 1, default 2
  hedges_correction = NULL, # drop down menu, one of NULL, TRUE, FALSE
  # optionally specify CI calculation method. 
  ci_methods = NULL, # drop down menu, one of NULL, "wald_t", "welch_t", "nct".
  
  # optionally assess the reported SMD can be reproduced by assuming the reported SDs are actually SEs 
  include_se_sd_confusion = FALSE, # drop down menu, one of FALSE, TRUE, defaults to FALSE
)

# outputs on screen. Download html report should be the same as the template.
res$reproduced
plot_multiverse_p(res)
plot_multiverse_d(res)

```

## Bounds

```{r}
res$reproduced |>
  kable() |>
  kable_classic(full_width = FALSE)
```

## Individual possible values for p

```{r}
plot_multiverse_p(res)
plot_multiverse_p(res, distinct_and_rounded = FALSE)

# res$p_results |>
#   kable() |>
#   kable_classic(full_width = FALSE)
```

## Individual possible values for SMD

```{r}
plot_multiverse_d(res)
plot_multiverse_d(res, distinct_and_rounded = FALSE)

# res$d_results |>
#   kable() |>
#   kable_classic(full_width = FALSE)
```

# For multiple inputs

```{r}

dat <- simulation |>
  slice(1:8) |>
  unnest(results_original, names_sep = "_") |>
  select(m1 = results_original_m1,
         m2 = results_original_m2,
         m_digits,
         sd1 = results_original_sd1,
         sd2 = results_original_sd2,
         n1 = results_original_n1,
         n2 = results_original_n2,
         sd_digits,
         input_rounding = input_rounding_method,
         #output_rounding, # = NULL, to run all
         
         d_digits,
         direction,
         hedges_correction,
         include_se_sd_confusion,
         d,
         #d_min = min_d_rounded,
         #d_max = max_d_rounded,
         #d_in_bounds = d_inbounds,
         
         p_digits,
         p_operator,
         p)
         #p_min = min_p_rounded,
         #p_max = max_p_rounded,
         #p_in_bounds = p_inbounds)

res <- dat |>
  rownames_to_column(var = "label") |>
  nest(data = c(m1,
                m2,
                m_digits,
                sd1,
                sd2,
                n1,
                n2,
                sd_digits,
                input_rounding,
                d_digits,
                direction,
                hedges_correction,
                include_se_sd_confusion,
                d,
                p_digits,
                p_operator,
                p),
       .by = label) |>
  mutate(
    data = future_pmap(
      .l = list(
        m1 = m1,
        m2 = m2,
        sd1 = sd1,
        sd2 = sd2,
        n1 = n1,
        n2 = n2,
        m_digits = m_digits,
        sd_digits = sd_digits,
        p_operator = p_operator,
        p = p,
        p_digits = p_digits,
        p_methods = p_methods,
        alpha = alpha,
        d = d,
        d_ci_lower = d_ci_lower,
        d_ci_upper = d_ci_upper,
        direction = direction,
        input_rounding = input_rounding,
        output_rounding = output_rounding,
        d_digits = d_digits,
        hedges_correction = hedges_correction,
        ci_methods = ci_methods,
        include_se_sd_confusion = include_se_sd_confusion
      ),
      .f = independent_t_test_summary,
      .progress = TRUE,
      .options = furrr_options(seed = TRUE)
    )
  ) |>
  # unnest results
  unnest(data)

```