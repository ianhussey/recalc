
\TODO 
psych::t2d() exists and could be added here
esc::esc_t() also exists and could be added here. esc::esc_mean_sd also useful


# Cohen's d_av

from M1, M2, SD1, SD2, and r

```{r}

# compare this one against the effectsize package
# estimateStandardizedMeanDifference is no longer available in esci, and isn't available in the git history.
# blog from 2020 mentions it: https://thenewstatistics.com/itns/2020/07/04/3-easy-ways-to-obtain-cohens-d-and-its-ci/
# but earlierst commit on github is mid 2023? https://github.com/rcalinjageman/esci/commit/76465649b721a48bc76503dfd27e58235a8f41a6
# this was a really handy function. Maybe I could reach out to the author for the old code?
cohens_dav <- function(data){
  require(esci)
  
  fit <- 
    esci::estimateStandardizedMeanDifference(m1 = data$mean_t2, 
                                             m2 = data$mean_t1, 
                                             s1 = data$sd_t2, 
                                             s2 = data$sd_t1, 
                                             n1 = data$n, 
                                             n2 = data$n,
                                             r  = data$r, 
                                             conf.level = .95,
                                             paired = TRUE) 
  
  return(tibble(es = fit$cohend,
                ci_lower = fit$cohend.low,
                ci_upper = fit$cohend.high,
                r  = fit$r))
}

```

# Cohen's d - between subjects

```{r}

# MBESS can also do it from data or from summary stats
# smd(Group.1 = NULL, Group.2 = NULL, Mean.1 = NULL, Mean.2 = NULL, 
# s.1 = NULL, s.2 = NULL, s = NULL, n.1 = NULL, n.2 = NULL,
# Unbiased=FALSE)

```


# Cohen's d_t

## dt dependent

from Westfall + others

Note that this method provides the same cohen's d estimate as cohen's d_z, ie d = mean_diff_scores / sd_diff_scores, but its CI's are slightly wider.

### with access to data

```{r}


# assumes that 'data' contains columns named score (numeric) and timepoint (factor with two levels, pre and post, where positive cohen's d means higher scores at post)
# assumes a two sided Student's t test with alpha = .05
# by default, assumes correlation between timepoints is 0. larger values will narrow the CIs but leave the estimate unchanged. so, default result is the worst case precision.
# note that Westfall 2016 (originally http://jakewestfall.org/blog/index.php/2016/03/25/five-different-cohens-d-statistics-for-within-subject-designs/ but no longer, a copy maintained at https://imaging.mrc-cbu.cam.ac.uk/statswiki/FAQ/tdunpaired as of 2024) specifies the calculation of d differently in a way i don't understand and have not seen elsewhere.  commented out code below provides his alternative
d_t_dependent <- function(data, hedges_correction = FALSE, r = 0) { # assumes a correlation of 0 for simplicity
  require(dplyr)
  
  fit <- t.test(data$score[data$timepoint == "post"],
                data$score[data$timepoint == "pre"], 
                paired = TRUE)
  
  res <- 
    data.frame(t_stat = fit$statistic["t"],
               df = fit$parameter["df"],
               r = r) |>
    mutate(n = df + 1, # for dependent t test, n = df + 1
           dt_estimate = t_stat / sqrt(n), # for dependent t test, d_t = t / sqrt(n)
           #dt_estimate = t_stat * sqrt(2/n), # westfall specifies is as this, but doesn't seem common
           dt_estimate = ifelse(hedges_correction, 
                                dt_estimate * (1 - (3 / (4 * n - 9))),
                                dt_estimate),
           dt_se = sqrt((2 * (1 - r)) / n + (dt_estimate ^ 2) / (2 * n)), # default assumes a correlation of 0
           ci_lower = dt_estimate - (1.96 * dt_se),
           ci_upper = dt_estimate + (1.96 * dt_se),
           type = "d_t_dependent",
           hedges_correction = hedges_correction) |>
    dplyr::select(type, hedges_correction, estimate = dt_estimate, ci_lower, ci_upper)
  
  return(res)
}

bind_rows(
  d_t_dependent(dat, r = 0),
  d_t_dependent(dat, hedges_correction = TRUE, r = 0),
  d_t_dependent(dat, r = 0.5),
  d_t_dependent(dat, hedges_correction = TRUE, r = 0.5),
  d_t_dependent(dat, r = 1),
  d_t_dependent(dat, hedges_correction = TRUE, r = 1)
)

```

### only access to stats output

```{r}

# assumes that 'data' contains columns named score (numeric) and timepoint (factor with two levels, pre and post, where positive cohen's d means higher scores at post)
# assumes a two sided Student's t test with alpha = .05
# by default, assumes correlation between timepoints is 0. larger values will narrow the CIs but leave the estimate unchanged. so, default result is the worst case precision.
# note that Westfall 2016 (originally http://jakewestfall.org/blog/index.php/2016/03/25/five-different-cohens-d-statistics-for-within-subject-designs/ but no longer, a copy maintained at https://imaging.mrc-cbu.cam.ac.uk/statswiki/FAQ/tdunpaired as of 2024) specifies the calculation of d differently in a way i don't understand and have not seen elsewhere.  commented out code below provides his alternative
d_t_dependent_from_t_and_df <- function(t, df, r = 0, hedges_correction = FALSE) { 
  require(dplyr)
  
  res <- 
    data.frame(t_stat = t,
               df = df,
               r = r) |>
    mutate(n = df + 1, # for dependent t test, n = df + 1
           dt_estimate = t_stat / sqrt(n), # for dependent t test, d_t = t / sqrt(2/n)
           #dt_estimate = t_stat * sqrt(2/n), # westfall specifies is as this, but doesn't seem common
           dt_estimate = ifelse(hedges_correction, 
                                dt_estimate * (1 - (3 / (4 * n - 9))),
                                dt_estimate),
           dt_se = sqrt((2 * (1 - r)) / n + (dt_estimate ^ 2) / (2 * n)), # default assumes a correlation of 0
           ci_lower = dt_estimate - (1.96 * dt_se),
           ci_upper = dt_estimate + (1.96 * dt_se),
           type = "d_t_dependent",
           hedges_correction = hedges_correction) |>
    dplyr::select(type, hedges_correction, estimate = dt_estimate, ci_lower, ci_upper)
  
  return(res)
}

bind_rows(
  d_t_dependent_from_t_and_df(t = 2.05, df = 34, r = 0),
  d_t_dependent_from_t_and_df(t = 2.05, df = 34, hedges_correction = TRUE, r = 0),
  d_t_dependent_from_t_and_df(t = 2.05, df = 34, r = 0.5),
  d_t_dependent_from_t_and_df(t = 2.05, df = 34, hedges_correction = TRUE, r = 0.5),
  d_t_dependent_from_t_and_df(t = 2.05, df = 34, r = 1),
  d_t_dependent_from_t_and_df(t = 2.05, df = 34, hedges_correction = TRUE, r = 1)
)

```



## dt independent

dt from Lakens 2013

### with access to data

```{r}

# this one is unlikely to be useful as if you have access to the data you don't need to fudge N per condition
# # assumes a two sided Student's t test with alpha = .05
# # assumes that only the t test result (i.e., its t and df) are available (i.e., not the N per condition) and that it is a Students t-test rather than a Welches' t-test. 
# # if the n per condition are available, the CIs could be calculated more precisely by altering the function
# # if a Welches' t test, the conversion of df to N is imprecise, affecting the CIs.
# # assumes that 'data' contains columns named score (numeric) and timepoint (factor with two levels)
# d_t_independent_from_summary_stats <- function(data, hedges_correction = FALSE) {
#   fit <- t.test(score ~ timepoint, 
#                 data = data,
#                 paired = FALSE, 
#                 var.equal = TRUE)
#   
#   res <- 
#     data.frame(t_stat = fit$statistic["t"],
#                df = fit$parameter["df"]) |>
#     mutate(n = df + 2, # for independent t test, n = df + 2
#            n1 = n / 2, # assuming equal sample sizes for simplicity
#            n2 = n / 2, # assuming equal sample sizes for simplicity
#            dt_estimate = 2 * (t_stat * sqrt(n)), # d = t * sqrt(1/n1 + 1/n2) - from lakens 2013 text below equation 2
#            dt_estimate = ifelse(hedges_correction, 
#                                 dt_estimate * (1 - (3 / (4 * n - 9))),
#                                 dt_estimate),
#            dt_se = sqrt((n1 + n2) / (n1 * n2) + (dt_estimate^2) / (2 * (n1 + n2 - 2))),
#            ci_lower = dt_estimate - (1.96 * dt_se),
#            ci_upper = dt_estimate + (1.96 * dt_se),
#            type = "d_t_independent",
#            hedges_correction = hedges_correction) |>
#     dplyr::select(type, hedges_correction, estimate = dt_estimate, ci_lower, ci_upper)
#   
#   return(res)
# }
# 
# d_t_independent_from_summary_stats(dat)
# d_t_independent_from_summary_stats(dat, hedges_correction = TRUE)



# cohen's d from a Student's t test (two sided, alpha = .05)
# if a Welches' t test, the conversion of df to N is imprecise, affecting the CIs.
# assumes that 'data' contains columns named score (numeric) and timepoint (factor with two levels)
d_t_independent <- function(data, hedges_correction = FALSE) {
  require(dplyr)
  
  fit <- t.test(score ~ timepoint, 
                data = data,
                paired = FALSE, 
                var.equal = TRUE)
  
  res <- 
    data.frame(t_stat = fit$statistic["t"],
               df = fit$parameter["df"]) |>
    mutate(n1 = data |> filter(timepoint == "post") |> nrow(),
           n2 = data |> filter(timepoint == "pre") |> nrow(),
           dt_estimate = t_stat * sqrt(1/n1 + 1/n2), # d = t * sqrt(1/n1 + 1/n2) - from lakens 2013 equation 2
           dt_estimate = ifelse(hedges_correction, 
                                dt_estimate * (1 - (3 / (4 * n - 9))),
                                dt_estimate),
           dt_se = sqrt((n1 + n2) / (n1 * n2) + (dt_estimate^2) / (2 * (n1 + n2 - 2))),
           ci_lower = dt_estimate - (1.96 * dt_se),
           ci_upper = dt_estimate + (1.96 * dt_se),
           type = "d_t_independent",
           hedges_correction = hedges_correction) |>
    dplyr::select(type, hedges_correction, estimate = dt_estimate, ci_lower, ci_upper)
  
  return(res)
}

d_t_independent(dat)
d_t_independent(dat, hedges_correction = TRUE)

```

### only access to stats output

```{r}

# assumes a two sided Student's t test with alpha = .05
# assumes that only the t test result (i.e., its t and df) are available (i.e., not the N per condition) and that it is a Students t-test rather than a Welches' t-test. 
# if a Welches' t test, the conversion of df to N is imprecise, affecting the CIs.
d_t_independent_from_t_and_df <- function(t, df, hedges_correction = FALSE) {
  require(dplyr)
  
  res <- 
    data.frame(t_stat = t,
               df = df) |>
    mutate(n = df + 2, # for independent t test, n = df + 2
           n1 = n / 2, # assuming equal sample sizes for simplicity
           n2 = n / 2, # assuming equal sample sizes for simplicity
           dt_estimate = 2 * (t_stat * sqrt(n)), # d = t * sqrt(1/n1 + 1/n2) - from lakens 2013 text below equation 2
           dt_estimate = ifelse(hedges_correction, 
                                dt_estimate * (1 - (3 / (4 * n - 9))),
                                dt_estimate),
           dt_se = sqrt((n1 + n2) / (n1 * n2) + (dt_estimate^2) / (2 * (n1 + n2 - 2))),
           ci_lower = dt_estimate - (1.96 * dt_se),
           ci_upper = dt_estimate + (1.96 * dt_se),
           type = "d_t_independent",
           hedges_correction = hedges_correction) |>
    dplyr::select(type, hedges_correction, estimate = dt_estimate, ci_lower, ci_upper)
  
  return(res)
}

d_t_independent_from_t_and_df(t = 2.87, df = 32)
d_t_independent_from_t_and_df(t = 2.87, df = 32, hedges_correction = TRUE)



# cohen's d from a Student's t test (two sided, alpha = .05)
# if a Welches' t test, the conversion of df to N is imprecise, affecting the CIs.
d_t_independent_from_t_and_ns <- function(t, n1, n2, hedges_correction = FALSE) {
  require(dplyr)
  
  res <- 
    data.frame(t_stat = t,
               n1 = n1,
               n2 = n2) |>
    mutate(dt_estimate = t_stat * sqrt(1/n1 + 1/n2), # d = t * sqrt(1/n1 + 1/n2) - from lakens 2013 equation 2
           dt_estimate = ifelse(hedges_correction, 
                                dt_estimate * (1 - (3 / (4 * n - 9))),
                                dt_estimate),
           dt_se = sqrt((n1 + n2) / (n1 * n2) + (dt_estimate^2) / (2 * (n1 + n2 - 2))),
           ci_lower = dt_estimate - (1.96 * dt_se),
           ci_upper = dt_estimate + (1.96 * dt_se),
           type = "d_t_independent",
           hedges_correction = hedges_correction) |>
    dplyr::select(type, hedges_correction, estimate = dt_estimate, ci_lower, ci_upper)
  
  return(res)
}

d_t_independent_from_t_and_ns(t = 2.87, n1 = 22, n2 = 10)
d_t_independent_from_t_and_ns(t = 2.87, n1 = 22, n2 = 10, hedges_correction = TRUE)

```