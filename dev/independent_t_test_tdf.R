
#' @title Multiverse of Independent Samples t-test Results (t/df)
#'
#' @description
#' This function explores the "multiverse" of possible Cohen's *d* effect sizes,
#' confidence intervals (CIs), and *p*-values that are compatible with a reported
#' *t* statistic and degrees of freedom (\code{df}), optionally with group sizes
#' \code{n1} and \code{n2} to enable *d* and CI reconstruction.
#'
#' The multiverse is generated by varying:
#' \itemize{
#'   \item Input Rounding: Adjusting reported t and df by +/- half of the
#'         last decimal place (ULP - Unit in the Last Place).
#'   \item Effect Size Type: Using both Cohen's *d* and Hedges' *g* (if n1/n2 given).
#'   \item CI Methods: Wald-type CIs (using *z* or *t* distribution
#'         with pooled/Welch variance) and the Noncentral *t* (NCT) distribution.
#'   \item P-value Methods: Using *t*-tests (Student's) or *z*-approximations.
#'   \item Output Rounding: Applying different rounding methods ("half_up",
#'         "half_down", "bankers", "trunc") to the final *d*/CI/p-value.
#'   \item Direction: The calculation uses the direction implied by the sign of
#'         the supplied *t* statistic.
#' }
#'
#' @param t Numeric. Reported t-statistic.
#' @param df Numeric. Reported degrees of freedom.
#' @param n1 Numeric. Sample size of Group 1 (required for effect sizes).
#' @param n2 Numeric. Sample size of Group 2 (required for effect sizes).
#' @param d_est Numeric. Reported Cohen's d or Hedges' g estimate.
#' @param d_ci_lower Numeric. Reported lower bound of the CI for d.
#' @param d_ci_upper Numeric. Reported upper bound of the CI for d.
#' @param d_digits Integer. Number of decimal places reported for d/CI.
#' @param p_est Numeric. Reported p-value.
#' @param p_digits Integer. Number of decimal places reported for p-value.
#' @param alpha Numeric. Significance level for CIs (default is 0.05).
#' @param ci_methods Character vector. CI methods to include.
#'   Allowed: "wald_z", "wald_t", "welch_t", "welch_z", "nct".
#' @param p_methods Character vector. P-value methods to include.
#'   Allowed: "student_t", "student_z", "welch_z".
#' @param d_rounding_set Character vector. Rounding methods for d/CI.
#'   Allowed: "half_up", "half_down", "bankers", "trunc".
#'
#' @return A list with three elements:
#' \itemize{
#'   \item \code{reproduced}: Logical. TRUE if a combination of calculated
#'         and rounded *d* and CIs matches the reported ones.
#'   \item \code{d_results}: Data frame detailing all calculated effect sizes and CIs.
#'   \item \code{p_results}: Data frame detailing all calculated p-values.
#' }
#'
#' @importFrom roundwork round_up round_down round_trunc
#' @importFrom stats pt pnorm qt qnorm uniroot
#'
#' @export
independent_t_test_tdf <- function(
    t = NULL, df = NULL,
    n1 = NULL, n2 = NULL,
    d_est = NULL, d_ci_lower = NULL, d_ci_upper = NULL,
    d_digits = 2,
    p_est = NULL, p_digits = 3,
    alpha = 0.05,
    ci_methods     = NULL,
    p_methods      = NULL,
    d_rounding_set = NULL
) {

  params <- .multiverse_validate_and_setup_tdf(
    ci_methods, p_methods, d_rounding_set,
    t, df, n1, n2
  )

  d_est_num      <- if (!is.null(d_est)) as.numeric(d_est) else NA_real_
  d_ci_lower_num <- if (!is.null(d_ci_lower)) as.numeric(d_ci_lower) else NA_real_
  d_ci_upper_num <- if (!is.null(d_ci_upper)) as.numeric(d_ci_upper) else NA_real_
  p_est_num      <- if (!is.null(p_est)) as.numeric(p_est) else NA_real_

  d_results <- list()
  p_results <- list()
  idx_d <- 1
  idx_p <- 1

  res_t_df <- .multiverse_from_t_df(
    t, df, n1, n2,
    params$ci_methods, params$p_methods, params$d_rounding_set,
    d_digits, p_digits, alpha,
    d_est_num, d_ci_lower_num, d_ci_upper_num, p_est_num,
    have_n_for_t = params$have_n_for_t,
    idx_d, idx_p
  )
  d_results <- c(d_results, res_t_df$d_results)
  p_results <- c(p_results, res_t_df$p_results)

  d_out <- if (length(d_results) > 0) do.call(rbind, d_results) else NULL
  p_out <- if (length(p_results) > 0) do.call(rbind, p_results) else NULL

  if (!is.null(d_out)) {
    d_out <- d_out[order(!d_out$match_all,
                         !d_out$match_est,
                         !d_out$match_ci_lower,
                         !d_out$match_ci_upper), ]
  }

  list(
    reproduced = if (!is.null(d_out)) any(d_out$match_all, na.rm = TRUE) else FALSE,
    d_results  = d_out,
    p_results  = p_out
  )
}

# --- Internal Helper Functions (duplicated here) ---

#' @keywords internal
.get_digits <- function(x) {
  if (is.null(x) || length(x) == 0 || is.na(x)) return(0L)
  sx <- sub("^-", "", as.character(x[1L]))
  if (!grepl("\\.", sx)) return(0L)
  nchar(sub("^[^.]*\\.", "", sx))
}

#' @keywords internal
.adjust_value <- function(x, step, code) {
  if (step == 0) return(x)
  if (code == "minus") return(x - step)
  if (code == "plus")  return(x + step)
  x
}

#' @keywords internal
.nct_ci <- function(t_obs, df, alpha = 0.05, max_ncp = 1000) {
  suppress_nct_warning <- function(expr) {
    withCallingHandlers(
      expr,
      warning = function(w) {
        if (grepl("full precision may not have been achieved in 'pnt\\{final\\}'",
                  conditionMessage(w))) {
          invokeRestart("muffleWarning")
        }
      }
    )
  }

  fL <- function(delta) suppress_nct_warning(pt(t_obs, df = df, ncp = delta) - alpha / 2)
  fU <- function(delta) suppress_nct_warning(pt(t_obs, df = df, ncp = delta, lower.tail = FALSE) - alpha / 2)

  lower <- -max_ncp
  upper <- max_ncp

  fL_low <- fL(lower)
  fL_high <- fL(upper)
  if (is.na(fL_low) || is.na(fL_high) || fL_low * fL_high > 0) {
    delta_L <- NA_real_
  } else {
    delta_L <- tryCatch(uniroot(fL, lower = lower, upper = upper)$root, error = function(e) NA_real_)
  }

  fU_low_check <- fU(upper)
  fU_high_check <- fU(lower)
  if (is.na(fU_low_check) || is.na(fU_high_check) || fU_low_check * fU_high_check > 0) {
    fU_low_rev <- fU(lower)
    fU_high_rev <- fU(upper)
    if (is.na(fU_low_rev) || is.na(fU_high_rev) || fU_low_rev * fU_high_rev > 0) {
      delta_U <- NA_real_
    } else {
      delta_U <- tryCatch(uniroot(fU, lower = lower, upper = upper)$root, error = function(e) NA_real_)
    }
  } else {
    delta_U <- tryCatch(uniroot(fU, lower = lower, upper = upper)$root, error = function(e) NA_real_)
  }

  c(delta_L, delta_U)
}

#' @keywords internal
.multiverse_validate_and_setup_tdf <- function(
    ci_methods, p_methods, d_rounding_set,
    t, df, n1, n2
) {
  allowed_ci_methods  <- c("wald_z", "wald_t", "welch_t", "welch_z", "nct")
  allowed_p_methods   <- c("student_t", "student_z", "welch_z")
  allowed_d_rounding  <- c("half_up", "half_down", "bankers", "trunc")

  check_methods <- function(input, allowed, name) {
    if (!is.null(input)) {
      bad <- setdiff(input, allowed)
      if (length(bad) > 0L) {
        stop(
          name, " contains invalid values: ",
          paste0(bad, collapse = ", "),
          "\nAllowed: ", paste0(allowed, collapse = ", ")
        )
      }
      return(input)
    }
    allowed
  }

  ci_methods      <- check_methods(ci_methods,      allowed_ci_methods, "ci_methods")
  p_methods       <- check_methods(p_methods,       allowed_p_methods,  "p_methods")
  d_rounding_set  <- check_methods(d_rounding_set,  allowed_d_rounding, "d_rounding_set")

  have_t <- !is.null(t) && !is.null(df) && !is.na(t) && !is.na(df)
  have_n_for_t <- !is.null(n1) && !is.null(n2) && !is.na(n1) && !is.na(n2)

  if (!have_t) {
    stop("Provide t and df.")
  }

  list(
    ci_methods  = ci_methods,
    p_methods   = p_methods,
    d_rounding_set = d_rounding_set,
    have_n_for_t = have_n_for_t
  )
}

#' @keywords internal
.multiverse_from_t_df <- function(
    t, df, n1, n2,
    ci_methods, p_methods, d_rounding_set,
    d_digits, p_digits, alpha,
    d_est_num, d_ci_lower_num, d_ci_upper_num, p_est_num,
    have_n_for_t,
    idx_d, idx_p
) {
  d_results <- list()
  p_results <- list()

  t_val <- as.numeric(t); df_t <- as.numeric(df)

  dig_t  <- .get_digits(t_val);  step_t  <- 0.5 * 10^(-dig_t)
  dig_df <- .get_digits(df_t);   step_df <- 0.5 * 10^(-dig_df)

  adj_codes <- c("reported", "minus", "plus")

  for (adj_tdf in adj_codes) {

    t_star  <- .adjust_value(t_val, step_t,  adj_tdf)
    df_star <- .adjust_value(df_t,  step_df, adj_tdf)
    if (!is.finite(df_star) || df_star <= 0) next

    if (have_n_for_t) {
      direction <- "t_sign"

      N    <- n1 + n2
      df_s <- n1 + n2 - 2
      fac_d <- sqrt(1 / n1 + 1 / n2)
      es_base <- t_star * fac_d

      J_t    <- 1 - 3 / (4 * df_star - 1)
      g_base <- J_t * es_base

      for (es_type in c("d", "g")) {

        es <- if (es_type == "d") es_base else g_base

        se_pooled <- sqrt(N / (n1 * n2) + es^2 / (2 * df_s))
        se_welch  <- sqrt(N / (n1 * n2) + es^2 / (2 * df_star))

        for (ci_method in ci_methods) {

          if (ci_method == "nct") {
            delta_ci <- .nct_ci(t_star, df_star, alpha = alpha)
            if (any(is.na(delta_ci))) next

            dL_raw <- delta_ci[1] * fac_d
            dU_raw <- delta_ci[2] * fac_d
            ci_lower <- if (es_type == "d") dL_raw else J_t * dL_raw
            ci_upper <- if (es_type == "d") dU_raw else J_t * dU_raw

          } else {
            if (ci_method %in% c("wald_z", "wald_t")) {
              se_use   <- se_pooled
              df_for_t <- df_s
            } else {
              se_use   <- se_welch
              df_for_t <- df_star
            }

            crit <- if (ci_method %in% c("wald_z", "welch_z")) {
              qnorm(1 - alpha / 2)
            } else {
              qt(1 - alpha / 2, df = df_for_t)
            }

            ci_lower <- es - crit * se_use
            ci_upper <- es + crit * se_use
          }

          for (d_rounding in d_rounding_set) {
            d_round_fun <- switch(
              d_rounding,
              "half_up"   = function(x) roundwork::round_up(x,   d_digits),
              "half_down" = function(x) roundwork::round_down(x, d_digits),
              "bankers"   = function(x) round(x, d_digits),
              "trunc"     = function(x) roundwork::round_trunc(x, d_digits),
              stop("Unknown d_rounding option")
            )

            est_r   <- d_round_fun(es)
            lower_r <- d_round_fun(ci_lower)
            upper_r <- d_round_fun(ci_upper)

            d_results[[idx_d]] <- data.frame(
              source              = "t_df",
              direction           = direction,
              es_type             = es_type,
              ci_method           = ci_method,
              d_rounding          = d_rounding,
              input_adj_stats     = NA_character_,
              input_adj_tdf       = adj_tdf,
              sd_interpretation   = NA_character_,
              m1_used             = NA_real_,
              m2_used             = NA_real_,
              sd1_used            = NA_real_,
              sd2_used            = NA_real_,
              t_used              = t_star,
              df_used             = df_star,
              es_unrounded        = es,
              ci_lower_unrounded  = ci_lower,
              ci_upper_unrounded  = ci_upper,
              est_rounded         = est_r,
              ci_lower_rounded    = lower_r,
              ci_upper_rounded    = upper_r,
              match_est      = if (!is.na(d_est_num))      isTRUE(all.equal(est_r,   d_est_num))      else NA,
              match_ci_lower = if (!is.na(d_ci_lower_num)) isTRUE(all.equal(lower_r, d_ci_lower_num)) else NA,
              match_ci_upper = if (!is.na(d_ci_upper_num)) isTRUE(all.equal(upper_r, d_ci_upper_num)) else NA,
              match_all      = if (!any(is.na(c(d_est_num, d_ci_lower_num, d_ci_upper_num)))) {
                est_r   == d_est_num &&
                  lower_r == d_ci_lower_num &&
                  upper_r == d_ci_upper_num
              } else NA,
              stringsAsFactors    = FALSE
            )
            idx_d <- idx_d + 1
          }
        }
      }
    }

    for (p_method in p_methods) {

      t_use <- t_star
      df_use <- if (p_method %in% c("student_z", "welch_z")) Inf else df_star

      p_unr <- if (is.infinite(df_use)) {
        2 * (1 - pnorm(abs(t_use)))
      } else {
        2 * (1 - pt(abs(t_use), df = df_use))
      }

      for (p_rounding in c("half_up", "half_down")) {
        p_round_fun <- if (p_rounding == "half_up") {
          function(x) roundwork::round_up(x, p_digits)
        } else {
          function(x) roundwork::round_down(x, p_digits)
        }
        p_rounded <- p_round_fun(p_unr)

        p_results[[idx_p]] <- data.frame(
          source            = "t_df",
          direction         = "t_sign",
          p_method          = p_method,
          p_rounding        = p_rounding,
          input_adj_stats   = NA_character_,
          input_adj_tdf     = adj_tdf,
          sd_interpretation = NA_character_,
          t_used            = t_use,
          df_used           = df_use,
          p_unrounded       = p_unr,
          p_rounded         = p_rounded,
          match_p           = if (!is.na(p_est_num)) isTRUE(all.equal(p_rounded, p_est_num)) else NA,
          stringsAsFactors  = FALSE
        )
        idx_p <- idx_p + 1
      }
    }
  }

  list(d_results = d_results, p_results = p_results, idx_d = idx_d, idx_p = idx_p)
}
