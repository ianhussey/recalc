#' @title Calculate Multiverse of Independent Samples t-test Results
#'
#' @description
#' This function explores the "multiverse" of possible Cohen's *d* effect sizes,
#' confidence intervals (CIs), and *p*-values that are compatible with a set
#' of reported summary statistics (Means, SDs, Ns) or a reported *t* statistic and
#' degrees of freedom (\code{df}).
#'
#' The multiverse is generated by varying:
#' \itemize{
#'   \item **Input Rounding:** Adjusting reported statistics by +/- half of the
#'         last decimal place (ULP - Unit in the Last Place).
#'   \item **Effect Size Type:** Using both **Cohen's *d*** and **Hedges' *g***.
#'   \item **CI Methods:** Employing Wald-type CIs (using *z* or *t* distribution
#'         with pooled/Welch variance) and the Noncentral *t* (NCT) distribution.
#'   \item **P-value Methods:** Using *t*-tests (Student's pooled or Welch's
#'         unpooled) or *z*-approximations (pooled or Welch).
#'   \item **Output Rounding:** Applying different rounding methods ("half\_up",
#'         "half\_down", "bankers", "trunc") to the final *d*/CI/p-value to check
#'         for matches with reported values.
#'   \item **Direction:** The calculation uses the direction implied by the order of
#'         the supplied means ($M_1 - M_2$) or the sign of the supplied *t* statistic.
#'   \item **SD vs.\ SE Interpretation (optional):** If \code{include_se_sd_confusion = TRUE},
#'         the function also includes a branch where reported SDs are interpreted as
#'         standard errors and converted to SDs via \eqn{SD = SE \times \sqrt{n}} before
#'         computing *d*, CIs, and *p*-values.
#' }
#'
#' @param m1 Numeric. Mean of Group 1.
#' @param m2 Numeric. Mean of Group 2.
#' @param sd1 Numeric. Standard Deviation of Group 1 (assumed sample SD by default).
#' @param sd2 Numeric. Standard Deviation of Group 2 (assumed sample SD by default).
#' @param n1 Numeric. Sample size of Group 1.
#' @param n2 Numeric. Sample size of Group 2.
#' @param t Numeric. Reported t-statistic.
#' @param df Numeric. Reported degrees of freedom.
#' @param d_est Numeric. Reported Cohen's d or Hedges' g estimate.
#' @param d_ci_lower Numeric. Reported lower bound of the CI for d.
#' @param d_ci_upper Numeric. Reported upper bound of the CI for d.
#' @param d_digits Integer. Number of decimal places reported for d/CI.
#' @param p_est Numeric. Reported p-value.
#' @param p_digits Integer. Number of decimal places reported for p-value.
#' @param alpha Numeric. Significance level for CIs (default is 0.05).
#' @param ci_methods Character vector. CI methods to include.
#'   Allowed: "wald\_z", "wald\_t", "welch\_t", "welch\_z", "nct".
#' @param p_methods Character vector. P-value methods to include.
#'   Allowed: "student\_t", "welch\_t", "student\_z", "welch\_z".
#' @param d_rounding_set Character vector. Rounding methods for d/CI.
#'   Allowed: "half\_up", "half\_down", "bankers", "trunc".
#' @param include_se_sd_confusion Logical. If \code{TRUE}, the multiverse also
#'   includes a branch that interprets \code{sd1} and \code{sd2} as standard errors
#'   and converts them to SDs via \eqn{SD = SE \times \sqrt{n}} before computing
#'   effect sizes, CIs, and p-values. Default is \code{FALSE}.
#'
#' @return A list with three elements:
#' \itemize{
#'   \item \code{reproduced}: Logical. TRUE if a combination of calculated
#'         and rounded *d* and CIs matches the reported ones.
#'   \item \code{d_results}: Data frame detailing all calculated effect sizes and CIs.
#'         Contains an additional column \code{sd_interpretation} indicating whether
#'         SDs were used as reported ("sd") or derived from SE ("se_converted").
#'   \item \code{p_results}: Data frame detailing all calculated p-values.
#'         Also includes \code{sd_interpretation} for summary-statistics-based rows.
#' }
#' 
#' @importFrom roundwork round_up round_down round_trunc
#' @importFrom stats pt pnorm qt qnorm uniroot
#' 
#' @export
independent_t_test <- function(
    m1 = NULL, m2 = NULL, sd1 = NULL, sd2 = NULL, 
    n1 = NULL, n2 = NULL,
    t = NULL, df = NULL,
    d_est = NULL, d_ci_lower = NULL, d_ci_upper = NULL,
    d_digits = 2,
    p_est = NULL, p_digits = 3,
    alpha = 0.05,
    ci_methods     = NULL,
    p_methods      = NULL,
    d_rounding_set = NULL,
    include_se_sd_confusion = FALSE
) {
  
  # --- Setup and Validation ---
  params <- .multiverse_validate_and_setup(
    ci_methods, p_methods, d_rounding_set,
    m1, m2, sd1, sd2, n1, n2, t, df
  )
  
  have_summary <- params$have_summary
  have_t       <- params$have_t
  have_n_for_t <- params$have_n_for_t
  
  # warn if SE/SD confusion requested but has no effect
  if (isTRUE(include_se_sd_confusion) && !have_summary) {
    warning(
      "include_se_sd_confusion = TRUE, but m1/m2/sd1/sd2 were not supplied.\n",
      "This option is ignored when only t/df are provided."
    )
  }
  
  # Coerce reported values
  d_est_num      <- if (!is.null(d_est)) as.numeric(d_est) else NA_real_
  d_ci_lower_num <- if (!is.null(d_ci_lower)) as.numeric(d_ci_lower) else NA_real_
  d_ci_upper_num <- if (!is.null(d_ci_upper)) as.numeric(d_ci_upper) else NA_real_
  p_est_num      <- if (!is.null(p_est)) as.numeric(p_est) else NA_real_
  
  have_summary <- params$have_summary
  have_t       <- params$have_t
  have_n_for_t <- params$have_n_for_t
  
  d_results <- list()
  p_results <- list()
  idx_d <- 1
  idx_p <- 1
  
  # --- 1) From summary statistics (means, SDs, Ns) ---
  if (have_summary) {
    res_summary <- .multiverse_from_summary_stats(
      m1, m2, sd1, sd2, n1, n2,
      params$ci_methods, params$p_methods, params$d_rounding_set,
      d_digits, p_digits, alpha,
      d_est_num, d_ci_lower_num, d_ci_upper_num, p_est_num,
      idx_d, idx_p,
      include_se_sd_confusion = include_se_sd_confusion
    )
    d_results <- c(d_results, res_summary$d_results)
    p_results <- c(p_results, res_summary$p_results)
    idx_d <- res_summary$idx_d
    idx_p <- res_summary$idx_p
  }
  
  # --- 2) From t statistic and df ---
  # This block is guaranteed to run ONLY if have_summary is FALSE AND have_t is TRUE (by validation)
  if (have_t) {
    res_t_df <- .multiverse_from_t_df(
      t, df, n1, n2,
      params$ci_methods, params$p_methods, params$d_rounding_set,
      d_digits, p_digits, alpha,
      d_est_num, d_ci_lower_num, d_ci_upper_num, p_est_num,
      have_n_for_t,
      idx_d, idx_p
    )
    d_results <- c(d_results, res_t_df$d_results)
    p_results <- c(p_results, res_t_df$p_results)
    idx_d <- res_t_df$idx_d
    idx_p <- res_t_df$idx_p
  }
  
  d_out <- if (length(d_results) > 0) do.call(rbind, d_results) else NULL
  p_out <- if (length(p_results) > 0) do.call(rbind, p_results) else NULL
  
  # Final ordering of d_out
  if (!is.null(d_out)) {
    d_out <- d_out[order(!d_out$match_all,
                         !d_out$match_est,
                         !d_out$match_ci_lower,
                         !d_out$match_ci_upper), ]
  }
  
  list(
    reproduced = if (!is.null(d_out)) any(d_out$match_all, na.rm = TRUE) else FALSE,
    d_results  = d_out,
    p_results  = p_out
  )
}


# --- Internal Helper Functions ---

#' @keywords internal
.get_digits <- function(x) {
  if (is.null(x) || length(x) == 0 || is.na(x)) return(0L)
  sx <- sub("^-", "", as.character(x[1L]))
  if (!grepl("\\.", sx)) return(0L)
  nchar(sub("^[^.]*\\.", "", sx))
}

#' @keywords internal
.adjust_value <- function(x, step, code) {
  if (step == 0) return(x)
  if (code == "minus") return(x - step)
  if (code == "plus")  return(x + step)
  x  # "reported"
}

#' @keywords internal
.nct_ci <- function(t_obs, df, alpha = 0.05, max_ncp = 1000) {
  # Uses pt and uniroot.
  # Utility function to suppress the specific 'pnt{final}' warning during pt calls.
  suppress_nct_warning <- function(expr) {
    withCallingHandlers(expr, 
                              warning = function(w) {
                                # Check if the warning message contains the low-precision text
                                if (grepl("full precision may not have been achieved in 'pnt\\{final\\}'", conditionMessage(w))) {
                                  invokeRestart("muffleWarning")
                                }
                              }
    )
  }
  
  # Define the root functions, wrapping the core calculation in the suppressor
  fL <- function(delta) suppress_nct_warning(pt(t_obs, df = df, ncp = delta) - alpha / 2)
  fU <- function(delta) suppress_nct_warning(pt(t_obs, df = df, ncp = delta, lower.tail = FALSE) - alpha / 2)
  
  lower <- -max_ncp
  upper <- max_ncp
  
  # Try to find lower bound
  fL_low <- fL(lower)
  fL_high <- fL(upper)
  if (is.na(fL_low) || is.na(fL_high) || fL_low * fL_high > 0) {
    delta_L <- NA_real_
  } else {
    delta_L <- tryCatch(uniroot(fL, lower = lower, upper = upper)$root, error = function(e) NA_real_)
  }
  
  # Try to find upper bound (fU is decreasing, so check fU(upper) vs fU(lower))
  fU_low_check <- fU(upper)
  fU_high_check <- fU(lower)
  if (is.na(fU_low_check) || is.na(fU_high_check) || fU_low_check * fU_high_check > 0) {
    # If the standard bracketing fails, try the reverse bracketing
    fU_low_rev <- fU(lower)
    fU_high_rev <- fU(upper)
    if (is.na(fU_low_rev) || is.na(fU_high_rev) || fU_low_rev * fU_high_rev > 0) {
      delta_U <- NA_real_
    } else {
      # Use uniroot with standard brackets here
      delta_U <- tryCatch(uniroot(fU, lower = lower, upper = upper)$root, error = function(e) NA_real_)
    }
  } else {
    # Standard bracketing
    delta_U <- tryCatch(uniroot(fU, lower = lower, upper = upper)$root, error = function(e) NA_real_)
  }
  
  c(delta_L, delta_U)
}

#' @keywords internal
.multiverse_validate_and_setup <- function(
    ci_methods, p_methods, d_rounding_set,
    m1, m2, sd1, sd2, n1, n2, t, df
) {
  # --- Allowed values ---
  allowed_ci_methods  <- c("wald_z", "wald_t", "welch_t", "welch_z", "nct")
  allowed_p_methods   <- c("student_t", "welch_t", "student_z", "welch_z")
  allowed_d_rounding  <- c("half_up", "half_down", "bankers", "trunc")
  
  # --- Validation of methods (unchanged) ---
  check_methods <- function(input, allowed, name) {
    if (!is.null(input)) {
      bad <- setdiff(input, allowed)
      if (length(bad) > 0L) {
        stop(
          name, " contains invalid values: ",
          paste0(bad, collapse = ", "),
          "\nAllowed: ", paste0(allowed, collapse = ", ")
        )
      }
      return(input)
    }
    allowed
  }
  
  ci_methods      <- check_methods(ci_methods,      allowed_ci_methods, "ci_methods")
  p_methods       <- check_methods(p_methods,       allowed_p_methods,  "p_methods")
  d_rounding_set  <- check_methods(d_rounding_set,  allowed_d_rounding, "d_rounding_set")
  
  # --- Determine available information ---
  # have_summary: needs all M, SD, N
  vals_summary <- list(m1, m2, sd1, sd2, n1, n2)
  have_summary <- all(vapply(
    vals_summary,
    function(z) !is.null(z) && length(z) > 0 && !is.na(z[1L]),
    logical(1)
  ))
  
  # have_t: needs t and df
  have_t <- !is.null(t) && !is.null(df) && !is.na(t) && !is.na(df)
  
  # have_n_for_t: needs N1 and N2 (used if t/df are supplied)
  have_n_for_t <- !is.null(n1) && !is.null(n2) && !is.na(n1) && !is.na(n2)
  
  # --- ENFORCING MUTUAL EXCLUSIVITY AND DEPENDENCIES ---
  
  # Error 1: Both summary stats AND t/df supplied
  if (have_summary && have_t) {
    stop(
      "Please supply EITHER M/SD/N (m1, m2, sd1, sd2, n1, n2) OR t/df (t, df, n1, n2), but not both. ",
      "Providing both can lead to contradictory results due to rounding."
    )
  }
  
  # Error 2: t/df supplied without N1/N2
  if (have_t && !have_n_for_t) {
    stop(
      "If 't' and 'df' are supplied, 'n1' and 'n2' must also be supplied to calculate Cohen's d and CIs. ",
      "Unlike in meta-analysis, we cannot assume equal group sizes ('n1' == 'n2') when reconstructing a single published test."
    )
  }
  
  # Error 3: Nothing supplied
  if (!have_summary && !have_t) {
    stop("Provide either M/SD/N or t and df.")
  }
  
  # --- Return parameters (unchanged) ---
  list(
    ci_methods  = ci_methods,
    p_methods   = p_methods,
    d_rounding_set = d_rounding_set,
    have_summary = have_summary,
    have_t    = have_t,
    have_n_for_t = have_n_for_t
  )
}

#' @keywords internal
.multiverse_from_summary_stats <- function(
    m1, m2, sd1, sd2, n1, n2,
    ci_methods, p_methods, d_rounding_set,
    d_digits, p_digits, alpha,
    d_est_num, d_ci_lower_num, d_ci_upper_num, p_est_num,
    idx_d, idx_p,
    include_se_sd_confusion = FALSE
) {
  d_results <- list()
  p_results <- list()
  
  # Step sizes (based on reported values)
  dig_m1  <- .get_digits(m1);  step_m1  <- 0.5 * 10^(-dig_m1)
  dig_m2  <- .get_digits(m2);  step_m2  <- 0.5 * 10^(-dig_m2)
  dig_sd1 <- .get_digits(sd1); step_sd1 <- 0.5 * 10^(-dig_sd1)
  dig_sd2 <- .get_digits(sd2); step_sd2 <- 0.5 * 10^(-dig_sd2)
  
  adj_codes <- c("reported", "minus", "plus")
  sd_modes  <- c("sd")
  if (isTRUE(include_se_sd_confusion)) {
    sd_modes <- c(sd_modes, "se_converted")
  }
  
  for (adj_stats in adj_codes) {
    
    # Adjust reported inputs by +/- ULP
    m1_star  <- .adjust_value(m1,  step_m1,  adj_stats)
    m2_star  <- .adjust_value(m2,  step_m2,  adj_stats)
    sd1_star <- .adjust_value(sd1, step_sd1, adj_stats)
    sd2_star <- .adjust_value(sd2, step_sd2, adj_stats)
    
    # Try each SD interpretation
    for (sd_mode in sd_modes) {
      
      if (sd_mode == "sd") {
        sd1_eff <- sd1_star
        sd2_eff <- sd2_star
      } else { # "se_converted": treat reported SDs as SEs, convert via sqrt(n)
        sd1_eff <- sd1_star * sqrt(n1)
        sd2_eff <- sd2_star * sqrt(n2)
      }
      
      if (sd1_eff <= 0 || sd2_eff <= 0) next
      
      direction <- "m1_minus_m2" 
      diff_mean <- m1_star - m2_star
      
      df_s <- n1 + n2 - 2
      N    <- n1 + n2
      
      # Pooled SD calculation (using effective SDs)
      sp <- sqrt(((n1 - 1) * sd1_eff^2 + (n2 - 1) * sd2_eff^2) / df_s)
      if (!is.finite(sp) || sp <= 0) next
      
      # Pooled t (Student)
      t_pooled <- diff_mean / (sp * sqrt(1 / n1 + 1 / n2))
      
      # Welch variance, t, and df
      var1     <- sd1_eff^2
      var2     <- sd2_eff^2
      se_welch <- sqrt(var1 / n1 + var2 / n2)
      t_welch  <- diff_mean / se_welch
      
      num_w <- (var1 / n1 + var2 / n2)^2
      den_w <- (var1^2 / (n1^2 * (n1 - 1))) + (var2^2 / (n2^2 * (n2 - 1)))
      df_w <- num_w / den_w
      if (!is.finite(df_w) || df_w <= 0) df_w <- NA_real_
      
      # Cohen's d and Hedges' g (based on effective SDs)
      d_raw <- diff_mean / sp
      J_s   <- 1 - 3 / (4 * df_s - 1)
      g_raw <- J_s * d_raw
      
      # --- 1a) Effect sizes and CIs ---
      for (es_type in c("d", "g")) {
        
        es <- if (es_type == "d") d_raw else g_raw
        
        # SE for Wald CIs (pooled/Welch)
        se_pooled <- sqrt(N / (n1 * n2) + es^2 / (2 * df_s))
        se_welch  <- if (!is.na(df_w)) sqrt(N / (n1 * n2) + es^2 / (2 * df_w)) else NA_real_
        
        for (ci_method in ci_methods) {
          
          if (ci_method == "nct") {
            delta_ci <- .nct_ci(t_pooled, df_s, alpha = alpha)
            if (any(is.na(delta_ci))) next
            fac_d   <- sqrt(1 / n1 + 1 / n2)
            dL_raw  <- delta_ci[1] * fac_d
            dU_raw  <- delta_ci[2] * fac_d
            ci_lower <- if (es_type == "d") dL_raw else J_s * dL_raw
            ci_upper <- if (es_type == "d") dU_raw else J_s * dU_raw
          } else { # Wald-type CIs
            if (ci_method %in% c("wald_z", "wald_t")) {
              se_use   <- se_pooled
              df_for_t <- df_s
            } else { # welch_t, welch_z
              se_use   <- if (!is.na(se_welch)) se_welch else se_pooled
              df_for_t <- if (!is.na(df_w)) df_w else df_s
            }
            
            crit <- if (ci_method %in% c("wald_z", "welch_z")) {
              qnorm(1 - alpha / 2)
            } else {
              qt(1 - alpha / 2, df = df_for_t)
            }
            
            ci_lower <- es - crit * se_use
            ci_upper <- es + crit * se_use
          }
          
          for (d_rounding in d_rounding_set) {
            d_round_fun <- switch(
              d_rounding,
              "half_up"   = function(x) roundwork::round_up(x,   d_digits),
              "half_down" = function(x) roundwork::round_down(x, d_digits),
              "bankers"   = function(x) round(x, d_digits),
              "trunc"     = function(x) roundwork::round_trunc(x, d_digits),
              stop("Unknown d_rounding option")
            )
            
            est_r   <- d_round_fun(es)
            lower_r <- d_round_fun(ci_lower)
            upper_r <- d_round_fun(ci_upper)
            
            d_results[[idx_d]] <- data.frame(
              source              = "summary",
              direction           = direction,
              es_type             = es_type,
              ci_method           = ci_method,
              d_rounding          = d_rounding,
              input_adj_stats     = adj_stats,
              input_adj_tdf       = NA_character_,
              sd_interpretation   = sd_mode,  # "sd" or "se_converted"
              m1_used             = m1_star,
              m2_used             = m2_star,
              sd1_used            = sd1_eff,
              sd2_used            = sd2_eff,
              t_used              = t_pooled,
              df_used             = df_s,
              es_unrounded        = es,
              ci_lower_unrounded  = ci_lower,
              ci_upper_unrounded  = ci_upper,
              est_rounded         = est_r,
              ci_lower_rounded    = lower_r,
              ci_upper_rounded    = upper_r,
              match_est           = if (!is.na(d_est_num))      isTRUE(all.equal(est_r,   d_est_num))      else NA,
              match_ci_lower      = if (!is.na(d_ci_lower_num)) isTRUE(all.equal(lower_r, d_ci_lower_num)) else NA,
              match_ci_upper      = if (!is.na(d_ci_upper_num)) isTRUE(all.equal(upper_r, d_ci_upper_num)) else NA,
              match_all           = if (!any(is.na(c(d_est_num, d_ci_lower_num, d_ci_upper_num)))) {
                est_r == d_est_num &&
                  lower_r == d_ci_lower_num &&
                  upper_r == d_ci_upper_num
              } else NA,
              stringsAsFactors    = FALSE
            )
            idx_d <- idx_d + 1
          }
        }
      }
      
      # --- 1b) p-values ---
      for (p_method in p_methods) {
        
        t_use <- switch(
          p_method,
          "student_t" = t_pooled,
          "welch_t"   = t_welch,
          "student_z" = t_pooled,
          "welch_z"   = t_welch,
          NA_real_
        )
        
        df_use <- switch(
          p_method,
          "student_t" = df_s,
          "welch_t"   = df_w,
          "student_z" = Inf,
          "welch_z"   = Inf,
          NA_real_
        )
        
        if (is.na(t_use) || is.na(df_use) || (p_method == "welch_t" && is.na(df_w))) next
        
        p_unr <- if (is.infinite(df_use)) {
          2 * (1 - pnorm(abs(t_use)))
        } else {
          2 * (1 - pt(abs(t_use), df = df_use))
        }
        
        for (p_rounding in c("half_up", "half_down")) {
          p_round_fun <- if (p_rounding == "half_up") {
            function(x) roundwork::round_up(x, p_digits)
          } else {
            function(x) roundwork::round_down(x, p_digits)
          }
          p_rounded <- p_round_fun(p_unr)
          
          p_results[[idx_p]] <- data.frame(
            source            = "summary",
            direction         = direction,
            p_method          = p_method,
            p_rounding        = p_rounding,
            input_adj_stats   = adj_stats,
            input_adj_tdf     = NA_character_,
            sd_interpretation = sd_mode,  # "sd" or "se_converted"
            t_used            = t_use,
            df_used           = df_use,
            p_unrounded       = p_unr,
            p_rounded         = p_rounded,
            match_p           = if (!is.na(p_est_num)) isTRUE(all.equal(p_rounded, p_est_num)) else NA,
            stringsAsFactors  = FALSE
          )
          idx_p <- idx_p + 1
        }
      }
    } # end loop over sd_mode
  }   # end loop over adj_stats
  
  list(d_results = d_results, p_results = p_results, idx_d = idx_d, idx_p = idx_p)
}

#' @keywords internal
.multiverse_from_t_df <- function(
    t, df, n1, n2,
    ci_methods, p_methods, d_rounding_set,
    d_digits, p_digits, alpha,
    d_est_num, d_ci_lower_num, d_ci_upper_num, p_est_num,
    have_n_for_t,
    idx_d, idx_p
) {
  d_results <- list()
  p_results <- list()
  
  t_val <- as.numeric(t); df_t <- as.numeric(df)
  
  # Step sizes
  dig_t  <- .get_digits(t_val);  step_t  <- 0.5 * 10^(-dig_t)
  dig_df <- .get_digits(df_t);   step_df <- 0.5 * 10^(-dig_df)
  
  adj_codes <- c("reported", "minus", "plus")
  
  for (adj_tdf in adj_codes) {
    
    t_star  <- .adjust_value(t_val, step_t,  adj_tdf)
    df_star <- .adjust_value(df_t,  step_df, adj_tdf)
    if (!is.finite(df_star) || df_star <= 0) next
    
    # --- 2a) Effect sizes from t (needs n1/n2) ---
    if (have_n_for_t) {
      sign_flip <- 1
      direction <- "t_sign"   # use sign of t_star as direction
      
      N    <- n1 + n2
      df_s <- n1 + n2 - 2
      fac_d <- sqrt(1 / n1 + 1 / n2)
      es_base <- t_star * fac_d * sign_flip # sign_flip is 1, so es_base = t_star * fac_d
      
      J_t    <- 1 - 3 / (4 * df_star - 1)
      g_base <- J_t * es_base
      
      for (es_type in c("d", "g")) {
        
        es <- if (es_type == "d") es_base else g_base
        
        # SE under pooled df_s and df_star
        se_pooled <- sqrt(N / (n1 * n2) + es^2 / (2 * df_s))
        se_welch  <- sqrt(N / (n1 * n2) + es^2 / (2 * df_star))
        
        for (ci_method in ci_methods) {
          
          if (ci_method == "nct") {
            delta_ci <- .nct_ci(t_star, df_star, alpha = alpha)
            if (any(is.na(delta_ci))) next
            
            dL_raw <- delta_ci[1] * fac_d
            dU_raw <- delta_ci[2] * fac_d
            ci_lower <- if (es_type == "d") dL_raw else J_t * dL_raw
            ci_upper <- if (es_type == "d") dU_raw else J_t * dU_raw
            
          } else {
            if (ci_method %in% c("wald_z", "wald_t")) {
              se_use   <- se_pooled
              df_for_t <- df_s
            } else { # welch_t, welch_z
              se_use   <- se_welch
              df_for_t <- df_star
            }
            
            crit <- if (ci_method %in% c("wald_z", "welch_z")) {
              qnorm(1 - alpha / 2)
            } else {
              qt(1 - alpha / 2, df = df_for_t)
            }
            
            ci_lower <- es - crit * se_use
            ci_upper <- es + crit * se_use
          }
          
          for (d_rounding in d_rounding_set) {
            d_round_fun <- switch(
              d_rounding,
              "half_up"   = function(x) roundwork::round_up(x,   d_digits),
              "half_down" = function(x) roundwork::round_down(x, d_digits),
              "bankers"   = function(x) round(x, d_digits),
              "trunc"     = function(x) roundwork::round_trunc(x, d_digits),
              stop("Unknown d_rounding option")
            )
            
            est_r   <- d_round_fun(es)
            lower_r <- d_round_fun(ci_lower)
            upper_r <- d_round_fun(ci_upper)
            
            d_results[[idx_d]] <- data.frame(
              source              = "t_df",
              direction           = direction,
              es_type             = es_type,
              ci_method           = ci_method,
              d_rounding          = d_rounding,
              input_adj_stats     = NA_character_,
              input_adj_tdf       = adj_tdf,
              sd_interpretation   = NA_character_,
              m1_used             = NA_real_,
              m2_used             = NA_real_,
              sd1_used            = NA_real_,
              sd2_used            = NA_real_,
              t_used              = t_star,
              df_used             = df_star,
              es_unrounded        = es,
              ci_lower_unrounded  = ci_lower,
              ci_upper_unrounded  = ci_upper,
              est_rounded         = est_r,
              ci_lower_rounded    = lower_r,
              ci_upper_rounded    = upper_r,
              match_est      = if (!is.na(d_est_num))      isTRUE(all.equal(est_r,   d_est_num))      else NA,
              match_ci_lower = if (!is.na(d_ci_lower_num)) isTRUE(all.equal(lower_r, d_ci_lower_num)) else NA,
              match_ci_upper = if (!is.na(d_ci_upper_num)) isTRUE(all.equal(upper_r, d_ci_upper_num)) else NA,
              match_all      = if (!any(is.na(c(d_est_num, d_ci_lower_num, d_ci_upper_num)))) {
                est_r   == d_est_num &&
                  lower_r == d_ci_lower_num &&
                  upper_r == d_ci_upper_num
              } else NA,
              stringsAsFactors    = FALSE
            )
            idx_d <- idx_d + 1
          }
        }
      }
    } # end have_n_for_t
    
    # --- 2b) p-values (always works) ---
    for (p_method in p_methods) {
      
      t_use <- t_star
      df_use <- if (p_method %in% c("student_z", "welch_z")) Inf else df_star
      
      p_unr <- if (is.infinite(df_use)) {
        2 * (1 - pnorm(abs(t_use)))
      } else {
        2 * (1 - pt(abs(t_use), df = df_use))
      }
      
      for (p_rounding in c("half_up", "half_down")) {
        p_round_fun <- if (p_rounding == "half_up") {
          function(x) roundwork::round_up(x, p_digits)
        } else {
          function(x) roundwork::round_down(x, p_digits)
        }
        p_rounded <- p_round_fun(p_unr)
        
        p_results[[idx_p]] <- data.frame(
          source            = "t_df",
          direction         = "t_sign",
          p_method          = p_method,
          p_rounding        = p_rounding,
          input_adj_stats   = NA_character_,
          input_adj_tdf     = adj_tdf,
          sd_interpretation = NA_character_,
          t_used            = t_use,
          df_used           = df_use,
          p_unrounded       = p_unr,
          p_rounded         = p_rounded,
          match_p           = if (!is.na(p_est_num)) isTRUE(all.equal(p_rounded, p_est_num)) else NA,
          stringsAsFactors  = FALSE
        )
        idx_p <- idx_p + 1
      }
    }
  }
  
  list(d_results = d_results, p_results = p_results, idx_d = idx_d, idx_p = idx_p)
}
