#' @title Calculate Multiverse of Independent Samples t-test Results
#'
#' @description
#' This function explores the "multiverse" of possible Cohen's *d* effect sizes,
#' confidence intervals (CIs), and *p*-values that are compatible with a set
#' of reported summary statistics (Means, SDs, Ns) or a reported *t* statistic and
#' degrees of freedom (\code{df}).
#'
#' The multiverse is generated by varying:
#' \itemize{
#'   \item **Input Rounding:** Adjusting reported statistics by +/- half of the
#'         last decimal place (ULP - Unit in the Last Place).
#'   \item **Direction:** Considering both (M1 - M2) and (M2 - M1) for summary
#'         statistics, and positive/negative *t* for the *t*/df approach.
#'   \item **Effect Size Type:** Using both **Cohen's *d*** and **Hedges' *g***.
#'   \item **CI Methods:** Employing Wald-type CIs (using *z* or *t* distribution
#'         with pooled/Welch variance) and the Noncentral *t* (NCT) distribution.
#'   \item **P-value Methods:** Using *t*-tests (Student's pooled or Welch's
#'         unpooled) or *z*-approximations (pooled or Welch).
#'   \item **Output Rounding:** Applying different rounding methods ("half\_up",
#'         "half\_down", "bankers") to the final *d*/CI/p-value to check for matches
#'         with reported values.
#' }
#'
#' @param m1 Numeric. Mean of Group 1.
#' @param m2 Numeric. Mean of Group 2.
#' @param sd1 Numeric. Standard Deviation of Group 1 (assumed sample SD).
#' @param sd2 Numeric. Standard Deviation of Group 2 (assumed sample SD).
#' @param n1 Numeric. Sample size of Group 1.
#' @param n2 Numeric. Sample size of Group 2.
#' @param t Numeric. Reported t-statistic.
#' @param df Numeric. Reported degrees of freedom.
#' @param d_est Numeric. Reported Cohen's d or Hedges' g estimate.
#' @param d_ci_lower Numeric. Reported lower bound of the CI for d.
#' @param d_ci_upper Numeric. Reported upper bound of the CI for d.
#' @param d_digits Integer. Number of decimal places reported for d/CI.
#' @param p_est Numeric. Reported p-value.
#' @param p_digits Integer. Number of decimal places reported for p-value.
#' @param alpha Numeric. Significance level for CIs (default is 0.05).
#' @param ci_methods Character vector. CI methods to include.
#'   Allowed: "wald\_z", "wald\_t", "welch\_t", "welch\_z", "nct".
#' @param p_methods Character vector. P-value methods to include.
#'   Allowed: "student\_t", "welch\_t", "student\_z", "welch\_z".
#' @param d_rounding_set Character vector. Rounding methods for d/CI.
#'   Allowed: "half\_up", "half\_down", "bankers".
#'
#' @return A list with three elements:
#' \itemize{
#'   \item \code{reproduced}: Logical. TRUE if a combination of calculated
#'         and rounded *d* and CIs matches the reported ones.
#'   \item \code{d_results}: Data frame detailing all calculated effect sizes and CIs.
#'   \item \code{p_results}: Data frame detailing all calculated p-values.
#' }
#' 
#' @importFrom roundwork round_up round_down
#' @importFrom stats pt pnorm qt qnorm uniroot
#' 
#' @export
independent_t_test <- function(
    m1 = NULL, m2 = NULL, sd1 = NULL, sd2 = NULL, 
    n1 = NULL, n2 = NULL,
    t = NULL, df = NULL,
    d_est = NULL, d_ci_lower = NULL, d_ci_upper = NULL,
    d_digits = 2,
    p_est = NULL, p_digits = 3,
    alpha = 0.05,
    ci_methods     = NULL,
    p_methods      = NULL,
    d_rounding_set = NULL
) {
  
  # --- Setup and Validation ---
  params <- .multiverse_validate_and_setup(
    ci_methods, p_methods, d_rounding_set,
    m1, m2, sd1, sd2, n1, n2, t, df
  )
  
  # Coerce reported values
  d_est_num      <- if (!is.null(d_est)) as.numeric(d_est) else NA_real_
  d_ci_lower_num <- if (!is.null(d_ci_lower)) as.numeric(d_ci_lower) else NA_real_
  d_ci_upper_num <- if (!is.null(d_ci_upper)) as.numeric(d_ci_upper) else NA_real_
  p_est_num      <- if (!is.null(p_est)) as.numeric(p_est) else NA_real_
  
  have_summary <- params$have_summary
  have_t       <- params$have_t
  have_n_for_t <- params$have_n_for_t
  
  d_results <- list()
  p_results <- list()
  idx_d <- 1
  idx_p <- 1
  
  # --- 1) From summary statistics (means, SDs, Ns) ---
  if (have_summary) {
    res_summary <- .multiverse_from_summary_stats(
      m1, m2, sd1, sd2, n1, n2,
      params$ci_methods, params$p_methods, params$d_rounding_set,
      d_digits, p_digits, alpha,
      d_est_num, d_ci_lower_num, d_ci_upper_num, p_est_num,
      idx_d, idx_p
    )
    d_results <- c(d_results, res_summary$d_results)
    p_results <- c(p_results, res_summary$p_results)
    idx_d <- res_summary$idx_d
    idx_p <- res_summary$idx_p
  }
  
  # --- 2) From t statistic and df ---
  # This block is guaranteed to run ONLY if have_summary is FALSE AND have_t is TRUE (by validation)
  if (have_t) {
    res_t_df <- .multiverse_from_t_df(
      t, df, n1, n2,
      params$ci_methods, params$p_methods, params$d_rounding_set,
      d_digits, p_digits, alpha,
      d_est_num, d_ci_lower_num, d_ci_upper_num, p_est_num,
      have_n_for_t,
      idx_d, idx_p
    )
    d_results <- c(d_results, res_t_df$d_results)
    p_results <- c(p_results, res_t_df$p_results)
    idx_d <- res_t_df$idx_d
    idx_p <- res_t_df$idx_p
  }
  
  d_out <- if (length(d_results) > 0) do.call(rbind, d_results) else NULL
  p_out <- if (length(p_results) > 0) do.call(rbind, p_results) else NULL
  
  # Final ordering of d_out
  if (!is.null(d_out)) {
    d_out <- d_out[order(!d_out$match_all,
                         !d_out$match_est,
                         !d_out$match_ci_lower,
                         !d_out$match_ci_upper), ]
  }
  
  list(
    reproduced = if (!is.null(d_out)) any(d_out$match_all, na.rm = TRUE) else FALSE,
    d_results  = d_out,
    p_results  = p_out
  )
}


# --- Internal Helper Functions ---

#' @keywords internal
.get_digits <- function(x) {
  if (is.null(x) || length(x) == 0 || is.na(x)) return(0L)
  sx <- sub("^-", "", as.character(x[1L]))
  if (!grepl("\\.", sx)) return(0L)
  nchar(sub("^[^.]*\\.", "", sx))
}

#' @keywords internal
.adjust_value <- function(x, step, code) {
  if (step == 0) return(x)
  if (code == "minus") return(x - step)
  if (code == "plus")  return(x + step)
  x  # "reported"
}

#' @keywords internal
.nct_ci <- function(t_obs, df, alpha = 0.05, max_ncp = 1000) {
  # Uses pt and uniroot
  fL <- function(delta) pt(t_obs, df = df, ncp = delta) - alpha / 2
  fU <- function(delta) pt(t_obs, df = df, ncp = delta) - (1 - alpha / 2)
  
  lower <- -max_ncp
  upper <- max_ncp
  
  # Try to find lower bound
  fL_low <- fL(lower)
  fL_high <- fL(upper)
  if (is.na(fL_low) || is.na(fL_high) || fL_low * fL_high > 0) {
    delta_L <- NA_real_
  } else {
    delta_L <- tryCatch(uniroot(fL, lower = lower, upper = upper)$root, error = function(e) NA_real_)
  }
  
  # Try to find upper bound (fU is decreasing, so we check fU(upper) vs fU(lower))
  fU_low_check <- fU(upper)
  fU_high_check <- fU(lower)
  if (is.na(fU_low_check) || is.na(fU_high_check) || fU_low_check * fU_high_check > 0) {
    # If the standard bracketing fails, try the reverse bracketing
    fU_low_rev <- fU(lower)
    fU_high_rev <- fU(upper)
    if (is.na(fU_low_rev) || is.na(fU_high_rev) || fU_low_rev * fU_high_rev > 0) {
      delta_U <- NA_real_
    } else {
      delta_U <- tryCatch(uniroot(fU, lower = lower, upper = upper)$root, error = function(e) NA_real_)
    }
  } else {
    # Standard bracketing
    delta_U <- tryCatch(uniroot(fU, lower = lower, upper = upper)$root, error = function(e) NA_real_)
  }
  
  c(delta_L, delta_U)
}

#' @keywords internal
.multiverse_validate_and_setup <- function(
    ci_methods, p_methods, d_rounding_set,
    m1, m2, sd1, sd2, n1, n2, t, df
) {
  # --- Allowed values ---
  allowed_ci_methods <- c("wald_z", "wald_t", "welch_t", "welch_z", "nct")
  allowed_p_methods <- c("student_t", "welch_t", "student_z", "welch_z")
  allowed_d_rounding <- c("half_up", "half_down", "bankers")
  
  # --- Validation of methods (unchanged) ---
  check_methods <- function(input, allowed, name) {
    if (!is.null(input)) {
      bad <- setdiff(input, allowed)
      if (length(bad) > 0L) {
        stop(
          name, " contains invalid values: ",
          paste0(bad, collapse = ", "),
          "\nAllowed: ", paste0(allowed, collapse = ", ")
        )
      }
      return(input)
    }
    allowed
  }
  
  d_rounding_set <- check_methods(d_rounding_set, allowed_d_rounding, "d_rounding_set")
  
  # --- Determine available information ---
  # have_summary: needs all M, SD, N
  vals_summary <- list(m1, m2, sd1, sd2, n1, n2)
  have_summary <- all(vapply(
    vals_summary,
    function(z) !is.null(z) && length(z) > 0 && !is.na(z[1L]),
    logical(1)
  ))
  
  # have_t: needs t and df
  have_t <- !is.null(t) && !is.null(df) && !is.na(t) && !is.na(df)
  
  # have_n_for_t: needs N1 and N2 (used if t/df are supplied)
  have_n_for_t <- !is.null(n1) && !is.null(n2) && !is.na(n1) && !is.na(n2)
  
  # --- ENFORCING MUTUAL EXCLUSIVITY AND DEPENDENCIES ---
  
  # Error 1: Both summary stats AND t/df supplied
  if (have_summary && have_t) {
    stop(
      "Please supply EITHER M/SD/N (m1, m2, sd1, sd2, n1, n2) OR t/df (t, df, n1, n2), but not both. ",
      "Providing both can lead to contradictory results due to rounding."
    )
  }
  
  # Error 2: t/df supplied without N1/N2
  if (have_t && !have_n_for_t) {
    stop(
      "If 't' and 'df' are supplied, 'n1' and 'n2' must also be supplied to calculate Cohen's d and CIs. ",
      "Unlike in meta-analysis, we cannot assume equal group sizes ('n1' == 'n2') when reconstructing a single published test."
    )
  }
  
  # Error 3: Nothing supplied
  if (!have_summary && !have_t) {
    stop("Provide either M/SD/N or t and df.")
  }
  
  # --- Return parameters (unchanged) ---
  list(
    ci_methods  = ci_methods,
    p_methods   = p_methods,
    d_rounding_set = d_rounding_set,
    have_summary = have_summary,
    have_t    = have_t,
    have_n_for_t = have_n_for_t
  )
}

#' @keywords internal
.multiverse_from_summary_stats <- function(
    m1, m2, sd1, sd2, n1, n2,
    ci_methods, p_methods, d_rounding_set,
    d_digits, p_digits, alpha,
    d_est_num, d_ci_lower_num, d_ci_upper_num, p_est_num,
    idx_d, idx_p
) {
  d_results <- list()
  p_results <- list()
  
  # Step sizes
  dig_m1 <- .get_digits(m1); step_m1 <- 0.5 * 10^(-dig_m1)
  dig_m2 <- .get_digits(m2); step_m2 <- 0.5 * 10^(-dig_m2)
  dig_sd1 <- .get_digits(sd1); step_sd1 <- 0.5 * 10^(-dig_sd1)
  dig_sd2 <- .get_digits(sd2); step_sd2 <- 0.5 * 10^(-dig_sd2)
  
  adj_codes <- c("reported", "minus", "plus")
  
  for (adj_stats in adj_codes) {
    
    m1_star <- .adjust_value(m1, step_m1, adj_stats)
    m2_star <- .adjust_value(m2, step_m2, adj_stats)
    sd1_star <- .adjust_value(sd1, step_sd1, adj_stats)
    sd2_star <- .adjust_value(sd2, step_sd2, adj_stats)
    
    if (sd1_star <= 0 || sd2_star <= 0) next
    
    for (direction in c("m1_minus_m2", "m2_minus_m1")) {
      
      diff_mean <- if (direction == "m1_minus_m2") m1_star - m2_star else m2_star - m1_star
      df_s <- n1 + n2 - 2
      N  <- n1 + n2
      
      # Pooled SD calculation
      sp  <- sqrt(((n1 - 1) * sd1_star^2 + (n2 - 1) * sd2_star^2) / df_s)
      if (!is.finite(sp) || sp <= 0) next
      
      # Pooled t (Student)
      t_pooled <- diff_mean / (sp * sqrt(1 / n1 + 1 / n2))
      
      # Welch variance, t, and df
      var1 <- sd1_star^2; var2 <- sd2_star^2
      se_welch <- sqrt(var1 / n1 + var2 / n2)
      t_welch <- diff_mean / se_welch
      
      num_w <- (var1 / n1 + var2 / n2)^2
      den_w <- (var1^2 / (n1^2 * (n1 - 1))) + (var2^2 / (n2^2 * (n2 - 1)))
      df_w <- num_w / den_w
      if (!is.finite(df_w) || df_w <= 0) df_w <- NA_real_
      
      # Cohen's d and Hedges' g
      d_raw <- diff_mean / sp
      J_s <- 1 - 3 / (4 * df_s - 1)
      g_raw <- J_s * d_raw
      
      # --- 1a) Effect sizes and CIs ---
      for (es_type in c("d", "g")) {
        
        es <- if (es_type == "d") d_raw else g_raw
        
        # SE for Wald CIs (pooled/Welch)
        se_pooled <- sqrt(N / (n1 * n2) + es^2 / (2 * df_s))
        se_welch <- if (!is.na(df_w)) sqrt(N / (n1 * n2) + es^2 / (2 * df_w)) else NA_real_
        
        for (ci_method in ci_methods) {
          
          if (ci_method == "nct") {
            delta_ci <- .nct_ci(t_pooled, df_s, alpha = alpha)
            if (any(is.na(delta_ci))) next
            fac_d <- sqrt(1 / n1 + 1 / n2)
            dL_raw <- delta_ci[1] * fac_d; dU_raw <- delta_ci[2] * fac_d
            ci_lower <- if (es_type == "d") dL_raw else J_s * dL_raw
            ci_upper <- if (es_type == "d") dU_raw else J_s * dU_raw
          } else { # Wald-type CIs
            if (ci_method %in% c("wald_z", "wald_t")) {
              se_use <- se_pooled; df_for_t <- df_s
            } else { # welch_t, welch_z
              se_use <- if (!is.na(se_welch)) se_welch else se_pooled
              df_for_t <- if (!is.na(df_w)) df_w else df_s
            }
            
            crit <- if (ci_method %in% c("wald_z", "welch_z")) qnorm(1 - alpha / 2) else qt(1 - alpha / 2, df = df_for_t)
            
            ci_lower <- es - crit * se_use
            ci_upper <- es + crit * se_use
          }
          
          for (d_rounding in d_rounding_set) {
            d_round_fun <- switch(d_rounding,
                                  "half_up" = function(x) roundwork::round_up(x, d_digits),
                                  "half_down" = function(x) roundwork::round_down(x, d_digits),
                                  "bankers" = function(x) round(x, d_digits),
                                  stop("Unknown d_rounding option"))
            
            est_r <- d_round_fun(es)
            lower_r <- d_round_fun(ci_lower)
            upper_r <- d_round_fun(ci_upper)
            
            d_results[[idx_d]] <- data.frame(
              source       = "summary", direction = direction, es_type = es_type, ci_method = ci_method,
              d_rounding     = d_rounding, input_adj_stats = adj_stats, input_adj_tdf = NA_character_,
              m1_used      = m1_star, m2_used = m2_star, sd1_used = sd1_star, sd2_used = sd2_star,
              t_used       = t_pooled, df_used = df_s, es_unrounded = es,
              ci_lower_unrounded = ci_lower, ci_upper_unrounded = ci_upper,
              est_rounded    = est_r, ci_lower_rounded = lower_r, ci_upper_rounded = upper_r,
              match_est     = if (!is.na(d_est_num)) isTRUE(all.equal(est_r, d_est_num)) else NA,
              match_ci_lower   = if (!is.na(d_ci_lower_num)) isTRUE(all.equal(lower_r, d_ci_lower_num)) else NA,
              match_ci_upper   = if (!is.na(d_ci_upper_num)) isTRUE(all.equal(upper_r, d_ci_upper_num)) else NA,
              match_all     = if (!any(is.na(c(d_est_num, d_ci_lower_num, d_ci_upper_num)))) (est_r == d_est_num && lower_r == d_ci_lower_num && upper_r == d_ci_upper_num) else NA,
              stringsAsFactors  = FALSE
            )
            idx_d <- idx_d + 1
          }
        }
      }
      
      # --- 1b) p-values ---
      for (p_method in p_methods) {
        
        t_use <- switch(p_method,
                        "student_t" = t_pooled,
                        "welch_t" = t_welch,
                        "student_z" = t_pooled,
                        "welch_z" = t_welch, NA_real_)
        
        df_use <- switch(p_method,
                         "student_t" = df_s,
                         "welch_t" = df_w,
                         "student_z" = Inf,
                         "welch_z" = Inf, NA_real_)
        
        if (is.na(t_use) || is.na(df_use) || (p_method == "welch_t" && is.na(df_w))) next
        
        p_unr <- if (is.infinite(df_use)) 2 * (1 - pnorm(abs(t_use))) else 2 * (1 - pt(abs(t_use), df = df_use))
        
        for (p_rounding in c("half_up", "half_down")) {
          p_round_fun <- if (p_rounding == "half_up") function(x) roundwork::round_up(x, p_digits) else function(x) roundwork::round_down(x, p_digits)
          p_rounded <- p_round_fun(p_unr)
          
          p_results[[idx_p]] <- data.frame(
            t_used              = t_use, df_used = df_use, p_unrounded = p_unr, p_rounded = p_rounded,
            match_p             = if (!is.na(p_est_num)) isTRUE(all.equal(p_rounded, p_est_num)) else NA,
            stringsAsFactors    = FALSE
          )
          idx_p <- idx_p + 1
        }
      }
    }
  }
  
  list(d_results = d_results, p_results = p_results, idx_d = idx_d, idx_p = idx_p)
}

#' @keywords internal
.multiverse_from_t_df <- function(
    t, df, n1, n2,
    ci_methods, p_methods, d_rounding_set,
    d_digits, p_digits, alpha,
    d_est_num, d_ci_lower_num, d_ci_upper_num, p_est_num,
    have_n_for_t,
    idx_d, idx_p
) {
  d_results <- list()
  p_results <- list()
  
  t_val <- as.numeric(t); df_t <- as.numeric(df)
  
  # Step sizes
  dig_t <- .get_digits(t_val); step_t <- 0.5 * 10^(-dig_t)
  dig_df <- .get_digits(df_t); step_df <- 0.5 * 10^(-dig_df)
  
  adj_codes <- c("reported", "minus", "plus")
  
  for (adj_tdf in adj_codes) {
    
    t_star <- .adjust_value(t_val, step_t, adj_tdf)
    df_star <- .adjust_value(df_t, step_df, adj_tdf)
    if (!is.finite(df_star) || df_star <= 0) next
    
    # --- 2a) Effect sizes from t (needs n1/n2) ---
    if (have_n_for_t) {
      N  <- n1 + n2
      df_s <- n1 + n2 - 2
      fac_d <- sqrt(1 / n1 + 1 / n2)
      d_from_t <- t_star * fac_d
      
      for (sign_flip in c(1, -1)) {
        
        es_base <- d_from_t * sign_flip
        direction <- if (sign_flip == 1) "t_sign" else "neg_t_sign"
        
        J_t <- 1 - 3 / (4 * df_star - 1)
        g_base <- J_t * es_base
        
        for (es_type in c("d", "g")) {
          
          es <- if (es_type == "d") es_base else g_base
          
          # SE under pooled df_s and df_star
          se_pooled <- sqrt(N / (n1 * n2) + es^2 / (2 * df_s))
          se_welch <- sqrt(N / (n1 * n2) + es^2 / (2 * df_star))
          
          for (ci_method in ci_methods) {
            
            if (ci_method == "nct") {
              delta_ci <- .nct_ci(t_star, df_star, alpha = alpha)
              if (any(is.na(delta_ci))) next
              
              dL_raw <- delta_ci[1] * fac_d; dU_raw <- delta_ci[2] * fac_d
              ci_lower <- if (es_type == "d") dL_raw else J_t * dL_raw
              ci_upper <- if (es_type == "d") dU_raw else J_t * dU_raw
            } else {
              if (ci_method %in% c("wald_z", "wald_t")) {
                se_use <- se_pooled; df_for_t <- df_s
              } else { # welch_t, welch_z
                se_use <- se_welch; df_for_t <- df_star
              }
              
              crit <- if (ci_method %in% c("wald_z", "welch_z")) qnorm(1 - alpha / 2) else qt(1 - alpha / 2, df = df_for_t)
              
              ci_lower <- es - crit * se_use
              ci_upper <- es + crit * se_use
            }
            
            for (d_rounding in d_rounding_set) {
              d_round_fun <- switch(d_rounding,
                                    "half_up" = function(x) roundwork::round_up(x, d_digits),
                                    "half_down" = function(x) roundwork::round_down(x, d_digits),
                                    "bankers" = function(x) round(x, d_digits),
                                    stop("Unknown d_rounding option"))
              
              est_r <- d_round_fun(es)
              lower_r <- d_round_fun(ci_lower)
              upper_r <- d_round_fun(ci_upper)
              
              d_results[[idx_d]] <- data.frame(
                source       = "t_df", direction = direction, es_type = es_type, ci_method = ci_method,
                d_rounding     = d_rounding, input_adj_stats = NA_character_, input_adj_tdf = adj_tdf,
                m1_used      = NA_real_, m2_used = NA_real_, sd1_used = NA_real_, sd2_used = NA_real_,
                t_used       = t_star, df_used = df_star, es_unrounded = es,
                ci_lower_unrounded = ci_lower, ci_upper_unrounded = ci_upper,
                est_rounded    = est_r, ci_lower_rounded = lower_r, ci_upper_rounded = upper_r,
                match_est     = if (!is.na(d_est_num)) isTRUE(all.equal(est_r, d_est_num)) else NA,
                match_ci_lower   = if (!is.na(d_ci_lower_num)) isTRUE(all.equal(lower_r, d_ci_lower_num)) else NA,
                match_ci_upper   = if (!is.na(d_ci_upper_num)) isTRUE(all.equal(upper_r, d_ci_upper_num)) else NA,
                match_all     = if (!any(is.na(c(d_est_num, d_ci_lower_num, d_ci_upper_num)))) (est_r == d_est_num && lower_r == d_ci_lower_num && upper_r == d_ci_upper_num) else NA,
                stringsAsFactors  = FALSE
              )
              idx_d <- idx_d + 1
            }
          }
        }
      }
    } # end have_n_for_t
    
    # --- 2b) p-values (always works) ---
    for (p_method in p_methods) {
      
      t_use <- t_star
      df_use <- if (p_method %in% c("student_z", "welch_z")) Inf else df_star
      
      p_unr <- if (is.infinite(df_use)) 2 * (1 - pnorm(abs(t_use))) else 2 * (1 - pt(abs(t_use), df = df_use))
      
      for (p_rounding in c("half_up", "half_down")) {
        p_round_fun <- if (p_rounding == "half_up") function(x) roundwork::round_up(x, p_digits) else function(x) roundwork::round_down(x, p_digits)
        p_rounded <- p_round_fun(p_unr)
        
        p_results[[idx_p]] <- data.frame(
          source       = "t_df", direction = if (have_n_for_t) "t_sign" else NA_character_,
          p_method      = p_method, p_rounding = p_rounding,
          input_adj_stats  = NA_character_, input_adj_tdf = adj_tdf,
          t_used       = t_use, df_used = df_use, p_unrounded = p_unr, p_rounded = p_rounded,
          match_p      = if (!is.na(p_est_num)) isTRUE(all.equal(p_rounded, p_est_num)) else NA,
          stringsAsFactors  = FALSE
        )
        idx_p <- idx_p + 1
      }
    }
  }
  
  list(d_results = d_results, p_results = p_results, idx_d = idx_d, idx_p = idx_p)
}