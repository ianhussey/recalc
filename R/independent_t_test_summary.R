#' @title Multiverse of Independent Samples t-test Results (Summary Statistics)
#'
#' @description
#' This function explores the "multiverse" of possible Cohen's *d* effect sizes,
#' confidence intervals (CIs), and *p*-values that are compatible with a set
#' of reported summary statistics (Means, SDs, Ns).
#'
#' The multiverse is generated by varying:
#' \itemize{
#'   \item Input Rounding: Adjusting reported statistics by +/- half of the
#'         last decimal place (ULP - Unit in the Last Place).
#'   \item Effect Size Type: Using both Cohen's *d* and Hedges' *g*.
#'   \item CI Methods: Wald-type CIs (using *z* or *t* distribution
#'         with pooled/Welch variance) and the Noncentral *t* (NCT) distribution.
#'   \item P-value Methods: Using *t*-tests (Student's pooled or Welch's
#'         unpooled) or *z*-approximations (pooled or Welch).
#'   \item Output Rounding: Applying different rounding methods ("half_up",
#'         "half_down", "bankers", "trunc") to the final *d*/CI/p-value.
#'   \item Direction: The calculation uses the direction implied by the order of
#'         the supplied means (M1 - M2).
#'   \item SD vs. SE Interpretation (optional): If \code{include_se_sd_confusion = TRUE},
#'         the function also includes a branch where reported SDs are interpreted as
#'         standard errors and converted to SDs via \eqn{SD = SE \times \sqrt{n}} before
#'         computing *d*, CIs, and *p*-values.
#' }
#'
#' @param m1 Numeric. Mean of Group 1.
#' @param m2 Numeric. Mean of Group 2.
#' @param sd1 Numeric. Standard Deviation of Group 1 (assumed sample SD by default).
#' @param sd2 Numeric. Standard Deviation of Group 2 (assumed sample SD by default).
#' @param n1 Numeric. Sample size of Group 1.
#' @param n2 Numeric. Sample size of Group 2.
#' @param d_est Numeric. Reported Cohen's d or Hedges' g estimate.
#' @param d_ci_lower Numeric. Reported lower bound of the CI for d.
#' @param d_ci_upper Numeric. Reported upper bound of the CI for d.
#' @param d_digits Integer. Number of decimal places reported for d/CI.
#' @param p_est Numeric. Reported p-value.
#' @param p_digits Integer. Number of decimal places reported for p-value.
#' @param alpha Numeric. Significance level for CIs (default is 0.05).
#' @param ci_methods Character vector. CI methods to include.
#'   Allowed: "wald_z", "wald_t", "welch_t", "welch_z", "nct".
#' @param p_methods Character vector. P-value methods to include.
#'   Allowed: "student_t", "welch_t", "student_z", "welch_z".
#' @param d_rounding_set Character vector. Rounding methods for d/CI.
#'   Allowed: "half_up", "half_down", "bankers", "trunc".
#' @param include_se_sd_confusion Logical. If \code{TRUE}, the multiverse also
#'   includes a branch that interprets \code{sd1} and \code{sd2} as standard errors
#'   and converts them to SDs via \eqn{SD = SE \times \sqrt{n}} before computing
#'   effect sizes, CIs, and p-values. Default is \code{FALSE}.
#'
#' @return A list with three elements:
#' \itemize{
#'   \item \code{reproduced}: Logical. TRUE if a combination of calculated
#'         and rounded *d* and CIs matches the reported ones.
#'   \item \code{d_results}: Data frame detailing all calculated effect sizes and CIs.
#'         Contains an additional column \code{sd_interpretation} indicating whether
#'         SDs were used as reported ("sd") or derived from SE ("se_converted").
#'   \item \code{p_results}: Data frame detailing all calculated p-values.
#'         Also includes \code{sd_interpretation}.
#' }
#'
#' @importFrom roundwork round_up round_down round_trunc
#' @importFrom stats pt pnorm qt qnorm uniroot
#'
#' @export
independent_t_test_summary <- function(
    m1 = NULL, m2 = NULL, sd1 = NULL, sd2 = NULL,
    n1 = NULL, n2 = NULL,
    d_est = NULL, d_ci_lower = NULL, d_ci_upper = NULL,
    d_digits = 2,
    p_est = NULL, p_digits = 3,
    alpha = 0.05,
    ci_methods     = NULL,
    p_methods      = NULL,
    d_rounding_set = NULL,
    direction      = c("m1_minus_m2", "m2_minus_m1", "both"),
    include_se_sd_confusion = FALSE
) {
  
  direction <- match.arg(direction)

  params <- .multiverse_validate_and_setup_summary(
    ci_methods, p_methods, d_rounding_set,
    m1, m2, sd1, sd2, n1, n2
  )

  # Coerce reported values
  d_est_num      <- if (!is.null(d_est)) as.numeric(d_est) else NA_real_
  d_ci_lower_num <- if (!is.null(d_ci_lower)) as.numeric(d_ci_lower) else NA_real_
  d_ci_upper_num <- if (!is.null(d_ci_upper)) as.numeric(d_ci_upper) else NA_real_
  p_est_num      <- if (!is.null(p_est)) as.numeric(p_est) else NA_real_

  d_results <- list()
  p_results <- list()
  idx_d <- 1
  idx_p <- 1

  res_summary <- .multiverse_from_summary_stats(
    m1, m2, sd1, sd2, n1, n2,
    params$ci_methods, params$p_methods, params$d_rounding_set,
    d_digits, p_digits, alpha,
    d_est_num, d_ci_lower_num, d_ci_upper_num, p_est_num,
    idx_d, idx_p,
    direction = direction,
    include_se_sd_confusion = include_se_sd_confusion
  )
  d_results <- c(d_results, res_summary$d_results)
  p_results <- c(p_results, res_summary$p_results)

  d_out <- if (length(d_results) > 0) do.call(rbind, d_results) else NULL
  p_out <- if (length(p_results) > 0) do.call(rbind, p_results) else NULL

  if (!is.null(d_out)) {
    d_out <- d_out[order(!d_out$match_all,
                         !d_out$match_est,
                         !d_out$match_ci_lower,
                         !d_out$match_ci_upper), ]
  }

  list(
    reproduced = if (!is.null(d_out)) any(d_out$match_all, na.rm = TRUE) else FALSE,
    d_results  = d_out,
    p_results  = p_out
  )
}

# --- Internal Helper Functions ---

#' @keywords internal
.get_digits <- function(x) {
  if (is.null(x) || length(x) == 0 || is.na(x)) return(0L)
  sx <- sub("^-", "", as.character(x[1L]))
  if (!grepl("\\.", sx)) return(0L)
  nchar(sub("^[^.]*\\.", "", sx))
}

#' @keywords internal
.adjust_value <- function(x, step, code) {
  if (step == 0) return(x)
  if (code == "minus") return(x - step)
  if (code == "plus")  return(x + step)
  x  # "reported"
}

#' @keywords internal
.nct_ci <- function(t_obs, df, alpha = 0.05, max_ncp = 1000) {
  suppress_nct_warning <- function(expr) {
    withCallingHandlers(
      expr,
      warning = function(w) {
        if (grepl("full precision may not have been achieved in 'pnt\\{final\\}'",
                  conditionMessage(w))) {
          invokeRestart("muffleWarning")
        }
      }
    )
  }

  fL <- function(delta) suppress_nct_warning(pt(t_obs, df = df, ncp = delta) - alpha / 2)
  fU <- function(delta) suppress_nct_warning(pt(t_obs, df = df, ncp = delta, lower.tail = FALSE) - alpha / 2)

  lower <- -max_ncp
  upper <- max_ncp

  fL_low <- fL(lower)
  fL_high <- fL(upper)
  if (is.na(fL_low) || is.na(fL_high) || fL_low * fL_high > 0) {
    delta_L <- NA_real_
  } else {
    delta_L <- tryCatch(uniroot(fL, lower = lower, upper = upper)$root, error = function(e) NA_real_)
  }

  fU_low_check <- fU(upper)
  fU_high_check <- fU(lower)
  if (is.na(fU_low_check) || is.na(fU_high_check) || fU_low_check * fU_high_check > 0) {
    fU_low_rev <- fU(lower)
    fU_high_rev <- fU(upper)
    if (is.na(fU_low_rev) || is.na(fU_high_rev) || fU_low_rev * fU_high_rev > 0) {
      delta_U <- NA_real_
    } else {
      delta_U <- tryCatch(uniroot(fU, lower = lower, upper = upper)$root, error = function(e) NA_real_)
    }
  } else {
    delta_U <- tryCatch(uniroot(fU, lower = lower, upper = upper)$root, error = function(e) NA_real_)
  }

  c(delta_L, delta_U)
}

#' @keywords internal
.multiverse_validate_and_setup_summary <- function(
    ci_methods, p_methods, d_rounding_set,
    m1, m2, sd1, sd2, n1, n2
) {
  allowed_ci_methods  <- c("wald_z", "wald_t", "welch_t", "welch_z", "nct")
  allowed_p_methods   <- c("student_t", "welch_t", "student_z", "welch_z")
  allowed_d_rounding  <- c("half_up", "half_down", "bankers", "trunc")

  check_methods <- function(input, allowed, name) {
    if (!is.null(input)) {
      bad <- setdiff(input, allowed)
      if (length(bad) > 0L) {
        stop(
          name, " contains invalid values: ",
          paste0(bad, collapse = ", "),
          "\nAllowed: ", paste0(allowed, collapse = ", ")
        )
      }
      return(input)
    }
    allowed
  }

  ci_methods      <- check_methods(ci_methods,      allowed_ci_methods, "ci_methods")
  p_methods       <- check_methods(p_methods,       allowed_p_methods,  "p_methods")
  d_rounding_set  <- check_methods(d_rounding_set,  allowed_d_rounding, "d_rounding_set")

  vals_summary <- list(m1, m2, sd1, sd2, n1, n2)
  have_summary <- all(vapply(
    vals_summary,
    function(z) !is.null(z) && length(z) > 0 && !is.na(z[1L]),
    logical(1)
  ))

  if (!have_summary) {
    stop("Provide M/SD/N: m1, m2, sd1, sd2, n1, n2.")
  }

  list(
    ci_methods  = ci_methods,
    p_methods   = p_methods,
    d_rounding_set = d_rounding_set
  )
}

#' @keywords internal
.multiverse_from_summary_stats <- function(
    m1, m2, sd1, sd2, n1, n2,
    ci_methods, p_methods, d_rounding_set,
    d_digits, p_digits, alpha,
    d_est_num, d_ci_lower_num, d_ci_upper_num, p_est_num,
    idx_d, idx_p,
    direction = c("m1_minus_m2", "m2_minus_m1", "both"),
    include_se_sd_confusion = FALSE
) {
  d_results <- list()
  p_results <- list()
  
  direction <- match.arg(direction)
  dir_modes <- if (direction == "both") c("m1_minus_m2", "m2_minus_m1") else direction
  
  # Step sizes (based on reported values)
  dig_m1  <- .get_digits(m1);  step_m1  <- 0.5 * 10^(-dig_m1)
  dig_m2  <- .get_digits(m2);  step_m2  <- 0.5 * 10^(-dig_m2)
  dig_sd1 <- .get_digits(sd1); step_sd1 <- 0.5 * 10^(-dig_sd1)
  dig_sd2 <- .get_digits(sd2); step_sd2 <- 0.5 * 10^(-dig_sd2)
  
  adj_codes <- c("reported", "minus", "plus")
  
  sd_modes  <- c("sd")
  if (isTRUE(include_se_sd_confusion)) {
    sd_modes <- c(sd_modes, "se_converted")
  }
  
  for (adj_stats in adj_codes) {
    
    # Adjust reported inputs by +/- ULP
    m1_star  <- .adjust_value(m1,  step_m1,  adj_stats)
    m2_star  <- .adjust_value(m2,  step_m2,  adj_stats)
    sd1_star <- .adjust_value(sd1, step_sd1, adj_stats)
    sd2_star <- .adjust_value(sd2, step_sd2, adj_stats)
    
    for (sd_mode in sd_modes) {
      
      if (sd_mode == "sd") {
        sd1_eff <- sd1_star
        sd2_eff <- sd2_star
      } else { # "se_converted": treat reported SDs as SEs, convert via sqrt(n)
        sd1_eff <- sd1_star * sqrt(n1)
        sd2_eff <- sd2_star * sqrt(n2)
      }
      
      if (sd1_eff <= 0 || sd2_eff <= 0) next
      
      df_s <- n1 + n2 - 2
      N    <- n1 + n2
      
      # Pooled SD
      sp <- sqrt(((n1 - 1) * sd1_eff^2 + (n2 - 1) * sd2_eff^2) / df_s)
      if (!is.finite(sp) || sp <= 0) next
      
      var1 <- sd1_eff^2
      var2 <- sd2_eff^2
      se_welch_base <- sqrt(var1 / n1 + var2 / n2)
      
      num_w <- (var1 / n1 + var2 / n2)^2
      den_w <- (var1^2 / (n1^2 * (n1 - 1))) + (var2^2 / (n2^2 * (n2 - 1)))
      df_w <- num_w / den_w
      if (!is.finite(df_w) || df_w <= 0) df_w <- NA_real_
      
      # ----------------------------------------------------------
      # Loop over direction modes
      # ----------------------------------------------------------
      for (dir_mode in dir_modes) {
        
        sign_factor    <- if (dir_mode == "m1_minus_m2") 1 else -1
        direction_label <- dir_mode
        
        diff_mean <- sign_factor * (m1_star - m2_star)
        
        # t statistics
        t_pooled <- diff_mean / (sp * sqrt(1 / n1 + 1 / n2))
        t_welch  <- diff_mean / se_welch_base
        
        # Effect sizes
        d_raw <- diff_mean / sp
        J_s   <- 1 - 3 / (4 * df_s - 1)
        g_raw <- J_s * d_raw
        
        # ----------------------------------------------------------
        # Effect sizes + CIs
        # ----------------------------------------------------------
        for (es_type in c("d", "g")) {
          
          es <- if (es_type == "d") d_raw else g_raw
          
          se_pooled <- sqrt(N / (n1 * n2) + es^2 / (2 * df_s))
          se_welch  <- if (!is.na(df_w)) sqrt(N / (n1 * n2) + es^2 / (2 * df_w)) else NA_real_
          
          for (ci_method in ci_methods) {
            
            if (ci_method == "nct") {
              delta_ci <- .nct_ci(t_pooled, df_s, alpha = alpha)
              if (any(is.na(delta_ci))) next
              
              fac_d   <- sqrt(1 / n1 + 1 / n2)
              dL_raw  <- delta_ci[1] * fac_d
              dU_raw  <- delta_ci[2] * fac_d
              
              ci_lower <- if (es_type == "d") dL_raw else J_s * dL_raw
              ci_upper <- if (es_type == "d") dU_raw else J_s * dU_raw
              
            } else {
              if (ci_method %in% c("wald_z", "wald_t")) {
                se_use   <- se_pooled
                df_for_t <- df_s
              } else { # welch_t, welch_z
                se_use   <- if (!is.na(se_welch)) se_welch else se_pooled
                df_for_t <- if (!is.na(df_w)) df_w else df_s
              }
              
              crit <- if (ci_method %in% c("wald_z", "welch_z")) {
                qnorm(1 - alpha / 2)
              } else {
                qt(1 - alpha / 2, df = df_for_t)
              }
              
              ci_lower <- es - crit * se_use
              ci_upper <- es + crit * se_use
            }
            
            # Rounding of effect sizes
            for (d_rounding in d_rounding_set) {
              
              d_round_fun <- switch(
                d_rounding,
                "half_up"   = function(x) roundwork::round_up(x,   d_digits),
                "half_down" = function(x) roundwork::round_down(x, d_digits),
                "bankers"   = function(x) round(x, d_digits),
                "trunc"     = function(x) roundwork::round_trunc(x, d_digits),
                stop("Unknown d_rounding option")
              )
              
              est_r   <- d_round_fun(es)
              lower_r <- d_round_fun(ci_lower)
              upper_r <- d_round_fun(ci_upper)
              
              d_results[[idx_d]] <- data.frame(
                source              = "summary",
                direction           = direction_label,
                es_type             = es_type,
                ci_method           = ci_method,
                d_rounding          = d_rounding,
                input_adj_stats     = adj_stats,
                input_adj_tdf       = NA_character_,
                sd_interpretation   = sd_mode,
                m1_used             = m1_star,
                m2_used             = m2_star,
                sd1_used            = sd1_eff,
                sd2_used            = sd2_eff,
                t_used              = t_pooled,
                df_used             = df_s,
                es_unrounded        = es,
                ci_lower_unrounded  = ci_lower,
                ci_upper_unrounded  = ci_upper,
                est_rounded         = est_r,
                ci_lower_rounded    = lower_r,
                ci_upper_rounded    = upper_r,
                match_est      = if (!is.na(d_est_num))      isTRUE(all.equal(est_r,   d_est_num))      else NA,
                match_ci_lower = if (!is.na(d_ci_lower_num)) isTRUE(all.equal(lower_r, d_ci_lower_num)) else NA,
                match_ci_upper = if (!is.na(d_ci_upper_num)) isTRUE(all.equal(upper_r, d_ci_upper_num)) else NA,
                match_all      = if (!any(is.na(c(d_est_num, d_ci_lower_num, d_ci_upper_num)))) {
                  est_r   == d_est_num &&
                    lower_r == d_ci_lower_num &&
                    upper_r == d_ci_upper_num
                } else NA,
                stringsAsFactors    = FALSE
              )
              
              idx_d <- idx_d + 1
            }
          }
        }
        
        # ----------------------------------------------------------
        # p-values
        # ----------------------------------------------------------
        for (p_method in p_methods) {
          
          t_use <- switch(
            p_method,
            "student_t" = t_pooled,
            "welch_t"   = t_welch,
            "student_z" = t_pooled,
            "welch_z"   = t_welch,
            NA_real_
          )
          
          df_use <- switch(
            p_method,
            "student_t" = df_s,
            "welch_t"   = df_w,
            "student_z" = Inf,
            "welch_z"   = Inf,
            NA_real_
          )
          
          if (is.na(t_use) || is.na(df_use) || (p_method == "welch_t" && is.na(df_w))) next
          
          p_unr <- if (is.infinite(df_use)) {
            2 * (1 - pnorm(abs(t_use)))
          } else {
            2 * (1 - pt(abs(t_use), df = df_use))
          }
          
          for (p_rounding in c("half_up", "half_down")) {
            
            p_round_fun <- if (p_rounding == "half_up") {
              function(x) roundwork::round_up(x, p_digits)
            } else {
              function(x) roundwork::round_down(x, p_digits)
            }
            
            p_rounded <- p_round_fun(p_unr)
            
            p_results[[idx_p]] <- data.frame(
              source            = "summary",
              direction         = direction_label,
              p_method          = p_method,
              p_rounding        = p_rounding,
              input_adj_stats   = adj_stats,
              input_adj_tdf     = NA_character_,
              sd_interpretation = sd_mode,
              t_used            = t_use,
              df_used           = df_use,
              p_unrounded       = p_unr,
              p_rounded         = p_rounded,
              match_p           = if (!is.na(p_est_num)) isTRUE(all.equal(p_rounded, p_est_num)) else NA,
              stringsAsFactors  = FALSE
            )
            
            idx_p <- idx_p + 1
          }
        }
      } # end loop over dir_modes
    }
  }
  
  list(d_results = d_results, p_results = p_results, idx_d = idx_d, idx_p = idx_p)
}
