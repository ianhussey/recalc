---
title: "{recalc} simulation"
author: "Ian Hussey"
output: 
  html
---

# TODO

- how to handle "< .001"?


```{r include=FALSE}

# formatting options
# set default chunk options
knitr::opts_chunk$set(message = FALSE, 
                      warning = FALSE)

# disable scientific notation
options(scipen = 999) 

```

# Dependencies

```{r}

library(tibble)
library(roundwork)
library(ggstance)
# devtools::install_github("ianhussey/recalc")
#library(recalc)

library(tidyr)
library(dplyr)
library(forcats)
library(readr)
library(purrr) 
library(furrr)
library(ggplot2)
library(scales)
library(knitr)
library(kableExtra)
library(parameters)
library(effectsize)

options(scipen=999)

```

# Functions

```{r}

# functions for simulation
generate_data <- function(m1 = 0,
                          m2 = 0,
                          sd1 = 1,
                          sd2 = 1,
                          n1 = 20,
                          n2 = 20) {
  
  data1 <- 
    tibble(condition = "1",
           score = rnorm(n = n1, mean = m1, sd = sd1))
  
  data2 <- 
    tibble(condition = "2",
           score = rnorm(n = n2, mean = m2, sd = sd2))
  
  data_combined <- bind_rows(data1,
                             data2)
  
  return(data_combined)
}

analyze <- function(data, 
                    m_digits,
                    sd_digits,
                    d_digits,
                    p_digits,
                    input_rounding_method) {
  
  res_summary <- data |>
    group_by(condition) |>
    summarize(m = mean(score),
              sd = sd(score),
              n = n()) |>
    pivot_wider(names_from = condition, 
                names_sep = "",
                values_from = c("m", "sd", "n"))
  
  res_ttest <- 
    t.test(formula = score ~ condition, 
           data = data,
           var.equal = TRUE,
           alternative = "two.sided") |>
    model_parameters() |>
    as_tibble() |>
    select(t, df = df_error, p)
  
  res_d <- effectsize::cohens_d(score ~ condition,
                                data = data) |>
    as_tibble() |>
    select(d = Cohens_d,
           d_ci_lower = CI_low,
           d_ci_upper = CI_high)
    
  res <- bind_cols(res_summary, 
                   res_ttest,
                   res_d)
  
  if(input_rounding_method == "half_up"){
    res <- res |>
      mutate(m1 = round_up(m1, m_digits),
             m2 = round_up(m2, m_digits),
             sd1 = round_up(sd1, sd_digits),
             sd2 = round_up(sd2, sd_digits),
             d = round_up(d, d_digits),
             d_ci_lower = round_up(d_ci_lower, d_digits),
             d_ci_upper = round_up(d_ci_upper, d_digits),
             p = round_up(p, p_digits))
  } else if(input_rounding_method == "half_down"){
    res <- res |>
      mutate(m1 = round_down(m1, m_digits),
             m2 = round_down(m2, m_digits),
             sd1 = round_down(sd1, sd_digits),
             sd2 = round_down(sd2, sd_digits),
             d = round_down(d, d_digits),
             d_ci_lower = round_down(d_ci_lower, d_digits),
             d_ci_upper = round_down(d_ci_upper, d_digits),
             p = round_down(p, p_digits))
  } else if(input_rounding_method == "bankers"){
    res <- res |>
      mutate(m1 = round(m1, m_digits),
             m2 = round(m2, m_digits),
             sd1 = round(sd1, sd_digits),
             sd2 = round(sd2, sd_digits),
             d = round(d, d_digits),
             d_ci_lower = round(d_ci_lower, d_digits),
             d_ci_upper = round(d_ci_upper, d_digits),
             p = round(p, p_digits))
  } else if(input_rounding_method == "trunc"){
    res <- res |>
      mutate(m1 = round_trunc(m1, m_digits),
             m2 = round_trunc(m2, m_digits),
             sd1 = round_trunc(sd1, sd_digits),
             sd2 = round_trunc(sd2, sd_digits),
             d = round_trunc(d, d_digits),
             d_ci_lower = round_trunc(d_ci_lower, d_digits),
             d_ci_upper = round_trunc(d_ci_upper, d_digits),
             p = round_trunc(p, p_digits))
  } 
  
  return(res)
}

reconstruct <- function(results, 
                        m_digits,
                        sd_digits,
                        d_digits,
                        p_digits,
                        direction,
                        include_se_sd_confusion){
  independent_t_test_summary(
    m1 = results$m1,
    m2 = results$m2,
    sd1 = results$sd1,
    sd2 = results$sd2,
    n1 = results$n1,
    n2 = results$n2,
    d = results$d,
    d_ci_lower = results$d_ci_lower,
    d_ci_upper = results$d_ci_upper,
    p = results$p,
    m_digits = m_digits,
    sd_digits = sd_digits,
    d_digits = d_digits,
    direction = direction,
    p_digits = p_digits,
    include_se_sd_confusion = include_se_sd_confusion
  )$reproduced
}

```

# Run simulation

```{r}

# simulation parameters
experiment_parameters <- expand_grid(
  pop_m1 = 0,
  pop_m2 = c(0, 0.5),
  pop_sd1 = 1,
  pop_sd2 = c(1, 1.5),
  pop_n1 = 25,
  pop_n2 = c(25, 100),
  m_digits = 2,
  sd_digits = 2,
  d_digits = 2,
  p_digits = 3,
  input_rounding_method = c("half_up", "half_down", "bankers", "trunc"),
  include_se_sd_confusion = FALSE,
  direction = c("m1_minus_m2", "m2_minus_m1"),
  iteration = 1:1
) 

experiment_parameters <- expand_grid(
  pop_m1 = 0,
  pop_m2 = 0,
  pop_sd1 = 1,
  pop_sd2 = 1,
  pop_n1 = 25,
  pop_n2 = 25,
  m_digits = 2,
  sd_digits = 2,
  d_digits = 2,
  p_digits = 3,
  input_rounding_method = "trunc",
  include_se_sd_confusion = FALSE,
  direction = "m1_minus_m2",
  iteration = 1:100
) 

# set up parallelization
plan(multisession, workers = future::availableCores())

# set seed
set.seed(42)

# run simulation
simulation <- experiment_parameters |>
  mutate(generated_data = future_pmap(.l = list(m1 = pop_m1,
                                                m2 = pop_m2,
                                                sd1 = pop_sd1,
                                                sd2 = pop_sd2,
                                                n1 = pop_n1,
                                                n2 = pop_n2),
                                      .f = generate_data,
                                      .progress = TRUE,
                                      .options = furrr_options(seed = TRUE))) |>
  mutate(results_original = future_pmap(.l = list(data = generated_data,
                                                  m_digits = m_digits,
                                                  sd_digits = sd_digits,
                                                  d_digits = d_digits,
                                                  p_digits = p_digits,
                                                  input_rounding_method = input_rounding_method),
                                        .f = analyze,
                                        .progress = TRUE,
                                        .options = furrr_options(seed = TRUE))) |>
  mutate(results_reconstructed = future_pmap(.l = list(results = results_original,
                                                       m_digits = m_digits,
                                                       sd_digits = sd_digits,
                                                       d_digits = d_digits,
                                                       p_digits = p_digits,
                                                       direction = direction,
                                                       include_se_sd_confusion = include_se_sd_confusion),
                                             .f = reconstruct,
                                             .progress = TRUE,
                                             .options = furrr_options(seed = TRUE))) |>
  # unnest results
  unnest(results_reconstructed) |>
  mutate(d_beyond_bounds = case_when(d < min_d_rounded ~ d-min_d_rounded,
                                     d > max_d_rounded ~ max_d_rounded-d,
                                     TRUE ~ 0),
         d_abs_beyond_bounds = abs(d_beyond_bounds),
         p_beyond_bounds = case_when(p < min_p_rounded ~ p-min_p_rounded,
                                     p > max_p_rounded ~ max_p_rounded-p,
                                     TRUE ~ 0),
         p_abs_beyond_bounds = abs(p_beyond_bounds))

#write_rds(simulation, "simulation.rds")

```

# Summarize results

```{r}

#simulation <- read_rds("simulation.rds")

# summarize across iterations
simulation_summary_by_argument <- simulation |>
  group_by(pop_m1,
           pop_m2,
           pop_sd1,
           pop_sd2,
           pop_n1,
           pop_n2,
           m_digits,
           sd_digits,
           d_digits,
           p_digits,
           input_rounding_method,
           include_se_sd_confusion,
           direction,
           generated_data) |>
  summarize(max_d_abs_beyond_bounds = max(d_abs_beyond_bounds),
            max_p_abs_beyond_bounds = max(p_abs_beyond_bounds))

simulation_summary <- simulation |>
  summarize(prop_d_beyond_bounds = 1 - mean(d_inbounds),
            max_d_abs_beyond_bounds = max(d_abs_beyond_bounds),
            prop_p_beyond_bounds = 1 - mean(p_inbounds),
            max_p_abs_beyond_bounds = max(p_abs_beyond_bounds))

simulation_summary


# # table of results
# simulation_summary |>
#   kable() |>
#   kable_classic(full_width = FALSE)
# 
# # plot results
# ggplot(simulation_summary, aes(population_effect_size, proportion_of_significant_p_values)) +
#   geom_col() +
#   theme_linedraw() +
#   scale_y_continuous(breaks = breaks_pretty(n = 10),
#                      limits = c(0,1),
#                      name = "Proportion of significant p-values") +
#   scale_x_discrete(name = "Population effect size")

```

